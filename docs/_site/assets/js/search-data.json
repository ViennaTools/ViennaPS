{"0": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "SF6O2 Etching",
    "content": "#include &lt;psSF6O2Etching.hpp&gt; . The model for SF6O2 etching of silicon is based on a model by Belen et al. 1 and summarized here. For implementation details refer to here. To describe the feature scale simulation of SF6O2 plasma etching, the surface rates of both ions and neutral particles, specifically fluorine and oxygen, and the surface coverages of neutrals, are considered. Ray tracing is used for the calculation of the surface rates, which are used for calculating coverages during each time step. The etch rate is determined the three physical phenomena: . | Chemical etching | Physical sputtering | Ion-enhanced etching | . In the process of chemical etching, the fluorine from the SF6 species reacts with the exposed silicon surface. Physical sputtering is caused by high-energy ions impacting the surface. Due to an applied bias, ions strike the wafer surface with a high enough kinetic energy, $E_{ion} &gt; E_{th}$ to break the existing bonds in the silicon wafer or other exposed materials. Lastly, ion-enhanced etching, also known as reactive ion etching (RIE), combines the two previous effects. Since silicon surfaces that are saturated with fluorine are more prone to physical sputtering, the threshold energy for releasing the silicon atom $E_{th}$ is significantly reduced compared to non-fluorinated surfaces. Therefore, ion-enhanced etching provides an etch rate that is larger than the sum of the chemical etching and sputtering. The surface can be covered in fluorine or oxygen. The physical model keeps track of these coverages, given by $\\theta_F$ and $\\theta_O$, respectively, by calculating the flux-induced rates and considering the coverages from the previous time step. They are calculated with Langmuir–Hinshelwood-type surface site balance equations, given by: . \\begin{equation} \\sigma_{Si}\\cfrac{d\\theta_{F}}{dt}=\\beta_{F}\\Gamma_{F}\\left(1-\\theta_{F}-\\theta_{O}\\right)-k\\sigma_{Si}\\theta_{F}-2Y_{ie}\\Gamma_{i}\\theta_{F} \\label{equ:thetaF} \\end{equation} . \\begin{equation} \\sigma_{Si}\\cfrac{d\\theta_{O}}{dt}=\\beta_{O}\\Gamma_{O}\\left(1-\\theta_{F}-\\theta_{O}\\right)-\\beta\\sigma_{Si}\\theta_{O}-Y_{O}\\Gamma_{i}\\theta_{O} \\label{equ:thetaO} \\end{equation} . The term $\\sigma_{Si}$ represents the density of silicon at the surface point $\\vec{x}$ which is not included in the equations for legibility; $\\Gamma_F$, $\\Gamma_O$, and $\\Gamma_i$ are the emitted fluorine, oxygen, and ion fluxes, respectively; $\\beta_F$ and $\\beta_O$ are the sticking coefficients for fluorine and oxygen on a non-covered silicon substrate, respectively; $k$ is the chemical etch reaction rate constant; $\\beta$ is the oxygen recombination rate constant; and $Y_{ie}$ and $Y_O$ are the total ion-enhanced and oxygen etching yields, respectively. $Y_{ie}$ and $Y_O$ are yield functions that are dependent on the ion energies in the reactor. Since the surface movement is significantly smaller than the considered fluxes, it can be assumed that it does not impact the calculation. With this assumption of a pseudo-steady-state, the coverage equations can be set equal to zero, resulting in the following surface coverage equations: \\begin{equation} \\theta_{F}=\\left[1+\\left(\\cfrac{k\\sigma_{Si}+2Y_{ie}\\Gamma_{i}}{\\gamma_{F}\\Gamma_{F}}\\right)\\left(1+\\cfrac{\\gamma_{O}\\Gamma_{O}}{\\beta\\sigma_{Si}+Y_{O}\\Gamma_{i}}\\right)\\right]^{-1} \\end{equation} . \\begin{equation} \\theta_{O}=\\left[1+\\left(\\cfrac{\\beta\\sigma_{Si}+Y_{O}\\Gamma_{i}}{\\gamma_{O}\\Gamma_{O}}\\right)\\left(1+\\cfrac{\\gamma_{F}\\Gamma_{F}}{k\\sigma_{Si}+2Y_{ie}\\Gamma_{i}}\\right)\\right]^{-1} \\end{equation} . The reason that pseudo-steady-state can be assumed is that the incoming fluxes of all involved particles are in the order of 10$^{16}$–10$^{19}$ cm-1s-1, which is significantly larger than the surface etch rate ER, which is typically in the range of several nanometers per second. The oxygen particles do not take part in surface removal; instead, they occupy an area on the top surface layer and inhibit the effects of chemical etching by fluorine. Relating it to the parameters in the equation, the presence of oxygen (denoted by its flux $\\Gamma_{O}$) tends to reduce $\\theta_{F}$. Increasing the oxygen flux $\\Gamma_O$ increases the overall expression in the square brackets, which means $\\theta_{F}$ decreases. Since oxygen has a passivating effect, the etching of silicon proceeds only due to its reaction with fluorine and physical sputtering due to the incoming ion flux. At locations where oxygen coverage is high, only ion sputtering takes place. This brings us to the expression for the etch rate (ER), which is used to move the surface . \\begin{equation} \\textrm{ER}=\\cfrac{1}{\\rho_{Si}}\\left(\\cfrac{k\\sigma_{Si}\\theta_{F}}{4}+Y_{p}\\Gamma_{i}+Y_{ie}\\Gamma_{i}\\theta_{F}\\right), \\end{equation} where $\\rho_{Si}$ is the silicon density. The first, second, and third terms in the brackets of the etch rate equation represent the chemical etching, physical sputtering, and ion-enhanced etching, respectively. ",
    "url": "/models/prebuilt/SF6O2Etching.html#sf6o2-etching",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#sf6o2-etching"
  },"1": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Ions",
    "content": "Each ion is endowed with an initial energy and direction upon creation on the source plane. The assignment of initial energies is governed by a normal distribution, characterized by a mean energy value and an energy sigma, thus allowing for stochastic variations in the initial energy states of the ions. The distribution of initial ion directions is given by a power cosine source distribution, which is defined by the exponent of the power cosine distribution. Upon impact with the surface, an energy- and angle-dependent yield is computed, which contributes to the specific surface point’s rate. The yield is expressed as: \\begin{equation} Y(E,\\theta) = A\\left(\\sqrt{E} - \\sqrt{E_{th}}\\right)f(\\theta), \\end{equation} where $E$ denotes the particle energy and $\\theta$ its incident angle. Here, $A$ represents a yield coefficient, and $E_{\\text{th}}$ denotes the material’s threshold energy for physical sputtering. The function $f(\\theta)$, which characterizes the angle-dependence of the yield. For sputtering, the function is given by: \\begin{equation} f(\\theta) = (1 + B_{sp}(1-\\cos^2(\\theta)))\\cos(\\theta), \\end{equation} while for ion-enhanced etching, the function is given by: \\begin{equation} f(\\theta) = \\cos(\\theta). \\end{equation} . The ions can also reflect from the surface. Their energy loss during reflection is described by the model proposed by Belen et al 1. The current ray energy is multiplied by a factor $E_\\textrm{ref}$ ($0 \\leq E_\\textrm{ref} \\leq 1$) which depends on the incoming angle $\\theta$ in the following way: \\begin{equation} E_{\\textrm{ref}}= 1-(1-A)\\frac{\\frac{\\pi}{2}-\\theta}{\\frac{\\pi}{2}-\\theta_\\textrm{inflect}} \\quad \\text{ if } \\theta \\geqslant \\theta_\\textrm{inflect} \\end{equation} \\begin{equation} E_{\\textrm{ref}}=\\mathrm{A}\\left(\\frac{\\theta}{\\theta_\\textrm{inflect}}\\right)^{n_l} \\quad \\text{ if } \\theta&lt;\\theta_\\textrm{inflect}, \\end{equation} where $A = (1 + n(\\frac{\\pi}{2 \\theta_\\textrm{inflect}} - 1))^{-1}$. Ions striking the surface at an angle denoted by $\\theta$ relative to the surface normal undergo reflection, where the angular dispersion is characterized by a cosine function centered around the direction of specular reflection defined by $\\theta_\\textrm{spec}$. This reflection process distinguishes between ions approaching the surface at glancing angles, which undergo nearly perfect specular reflection, and those striking the surface perpendicularly, which undergo nearly diffuse reflection. \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{spec}}\\right) \\quad \\text{ if } \\theta_\\textrm{inc} \\leqslant \\theta_\\textrm{min} \\end{equation} . \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{min}}\\right) \\quad \\text{ if } \\theta_{\\textrm{inc}}&gt;\\theta_{\\textrm{min}} \\end{equation} . The ray’s reflected direction is randomly chosen from a cone around the specular direction. The opening angle of this cone is given by the incidence angle $\\theta$. The ions sticking probability is described by two parameters $\\theta_\\textrm{Rmin}$ and $\\theta_\\textrm{Rmax}$: \\begin{equation} \\beta_{ion} = 1 \\quad \\text{ if }\\theta \\leq \\theta_\\textrm{Rmin} \\end{equation} \\begin{equation} \\beta_{ion} = 1 - \\frac{\\theta - \\theta_\\textrm{Rmin}}{\\theta_\\textrm{Rmax}- \\theta_\\textrm{Rmin}} \\quad \\text{ if }\\theta &gt; \\theta_\\textrm{Rmin} \\end{equation} . ",
    "url": "/models/prebuilt/SF6O2Etching.html#ions",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#ions"
  },"2": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Neutrals",
    "content": "There are two neutral particle species in this model: etchant (Flourine) and oxygen. The sticking probability is a function of the surface coverage and the sticking probability of the respective particle. The sticking probability is given by: \\begin{equation} \\beta_{eff_{F/O}} = \\beta_{F/O} (1 - \\theta_F - \\theta_O) \\end{equation} Neutrals reflect diffusely from the surface with a cosine distribution. ",
    "url": "/models/prebuilt/SF6O2Etching.html#neutrals",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#neutrals"
  },"3": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Implementation",
    "content": "Time and length units have to be set before initializing the model. For details see Units. SF6O2Etching() // use default values only SF6O2Etching(const double ionFlux, const double etchantFlux, const double oxygenFlux, const NumericType meanEnergy /* eV */, const NumericType sigmaEnergy /* eV */, const NumericType ionExponent = 100., const NumericType oxySputterYield = 2., const NumericType etchStopDepth = std::numeric_limits&lt;NumericType&gt;::lowest()) SF6O2Etching(const SF6O2Parameters&lt;NumericType&gt; &amp;parameters) . Users can access and modify all detailed parameters by creating a SF6O2Parameters struct, which encapsulates the following values: . All flux values are units 1015 / cm2 /s2. | Parameter | Description | Default Value | . | ionFlux | Ion flux | 12.0 | . | etchantFlux | Etchant flux | 1800.0 | . | oxygenFlux | Oxygen flux | 100.0 | . | beta_F | Sticking probability map for fluorine | 0.7 (on Si and Mask) | . | beta_O | Sticking probability map for oxygen | 1.0 (on Si and Mask) | . | etchStopDepth | Depth at which etching stops | -inf | . | fluxIncludeSticking | Include the effective sticking probability when accumlating fluxes, Required more iterations to reach coverage convergence | false | . | Mask.rho | Mask density (1022 atoms/cm³) | 500.0 | . | Mask.Eth_sp | Mask sputtering threshold energy (eV) | 20.0 | . | Mask.A_sp | Mask sputtering coefficient | 0.0139 | . | Mask.B_sp | Mask sputtering coefficient | 9.3 | . | Si.rho | Silicon density (1022 atoms/cm³) | 5.02 | . | Si.Eth_sp | Silicon sputtering threshold energy (eV) | 20.0 | . | Si.Eth_ie | Silicon ion enhanced etching threshold energy (eV) | 15.0 | . | Si.A_sp | Silicon sputtering coefficient | 0.0337 | . | Si.B_sp | Silicon sputtering coefficient | 9.3 | . | Si.A_ie | Silicon ion enhanced etching coefficient | 7.0 | . | Si.k_sigma | Silicon chemical etch rate coefficient (1015 /cm² /s) | 300. | . | Si.beta_sigma | Silicon oxygen recombination coefficient (1015 /cm² /s) | 0.05 | . | Passivation.Eth_ie | Passivation ion enhanced etching threshold energy (eV) | 10.0 | . | Passivation.A_ie | Passivation ion enhanced etching coefficient | 3.0 | . | Ions.meanEnergy | Mean ion energy (eV) | 100.0 | . | Ions.sigmaEnergy | Standard deviation of ion energy (eV) | 10.0 | . | Ions.exponent | Exponent of power cosine source distribution of initial ion directions | 500.0 | . | Ions.inflectAngle | Inflection angle (rad) | 1.55334303 | . | Ions.n_l | Exponent of reflection power | 10.0 | . | Ions.minAngle | Minimum cone angle for ion reflection | 1.3962634 | . | Ions.thetaRMin | Minimum angle for ion sticking probability | 70.0 (deg) | . | Ions.thetaRMax | Maximum angle for ion sticking probability | 90.0 (deg) | . Example usage: . C++ . // namespace viennaps ... SF6O2Parameters&lt;NumericType&gt; parameters; parameters.ionFlux = 10.; parameters.Mask.rho = 500.; auto model = SmartPointer&lt;SF6O2Etching&lt;NumericType, D&gt;&gt;::New(parameters); ... Python ... parameters = vps.SF6O2Parameters() parameters.ionFlux = 10. parameters.Mask.rho = 500. model = vps.SF6O2Etching(parameters) ... ",
    "url": "/models/prebuilt/SF6O2Etching.html#implementation",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#implementation"
  },"4": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "Related Examples",
    "content": ". | Hole Etching | . | Rodolfo Jun Belen, Sergi Gomez, Mark Kiehlbauch, David Cooperberg, Eray S. Aydil; Feature-scale model of Si etching in SF6 plasma and comparison with experiments. J. Vac. Sci. Technol. A 1 January 2005; 23 (1): 99–113. https://doi.org/10.1116/1.1830495 &#8617; &#8617;2 . | . ",
    "url": "/models/prebuilt/SF6O2Etching.html#related-examples",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html#related-examples"
  },"5": {
    "doc": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "title": "SF<sub>6</sub>O<sub>2</sub> Etching",
    "content": " ",
    "url": "/models/prebuilt/SF6O2Etching.html",
    
    "relUrl": "/models/prebuilt/SF6O2Etching.html"
  },"6": {
    "doc": "TEOSPECVD Process",
    "title": "TEOS Plasma-Enhanced (PE) Chemical Vapor Deposition (CVD)",
    "content": "#include &lt;psTEOSPECVD.hpp&gt; . The TEOS PE CVD process is a deposition process with an additional plasma-enhanced component, which supplies directional ions during the process. The process is specified by two particle species: the TEOS precursor radicals and the ions. The depostion rate is controlled by a reaction order for both radicals and ions, where the final surface velocity $v$ follows: \\begin{equation} v = R_{rad} \\cdot \\Gamma_{rad}^{o_{rad}} + R_{ion} \\cdot \\Gamma_{ion}^{o_{ion}} \\end{equation} where $R_{rad}$ and $R_{ion}$ are the rates of the radicals and ions, respectively, and $\\Gamma_{rad}$ and $\\Gamma_{ion}$ are the fluxes of the radicals and ions, respectively. The exponents $o_{rad}$ and $o_{ion}$ are the reaction orders of the radicals and ions, respectively. The sticking probability of the TEOS precursor radicals and the ions can be specified, as well as the exponent of the power cosine distribution of the ions. The TEOS radicals reflect diffusively from the surface, while the ions can reflect near specularly from the surface with a minimum angle specified. ",
    "url": "/models/prebuilt/TEOSPECVD.html#teos-plasma-enhanced-pe-chemical-vapor-deposition-cvd",
    
    "relUrl": "/models/prebuilt/TEOSPECVD.html#teos-plasma-enhanced-pe-chemical-vapor-deposition-cvd"
  },"7": {
    "doc": "TEOSPECVD Process",
    "title": "Implementation",
    "content": "TEOSPECVD(const NumericType pRadicalSticking, const NumericType pRadicalRate, const NumericType pIonRate, const NumericType pIonExponent, const NumericType pIonSticking = 1., const NumericType pRadicalOrder = 1., const NumericType pIonOrder = 1., const NumericType pIonMinAngle = 0.) . | Parameter | Description | Default Value | . | pRadicalSticking | Sticking probability of the TEOS precursor radicals | 1.0 | . | pRadicalRate | Rate of the TEOS precursor radicals | 1.0 | . | pIonRate | Rate of the ions | 1.0 | . | pIonExponent | Exponent power cosine source distribution of the ions | 1.0 | . | pIonSticking | Sticking probability of the ions | 1.0 | . | pRadicalOrder | Reaction order of the TEOS precursor radicals | 1.0 | . | pIonOrder | Reaction order of the ions | 1.0 | . | pIonMinAngle | Minimum specular reflection angle of the ions | 0.0 | . ",
    "url": "/models/prebuilt/TEOSPECVD.html#implementation",
    
    "relUrl": "/models/prebuilt/TEOSPECVD.html#implementation"
  },"8": {
    "doc": "TEOSPECVD Process",
    "title": "TEOSPECVD Process",
    "content": " ",
    "url": "/models/prebuilt/TEOSPECVD.html",
    
    "relUrl": "/models/prebuilt/TEOSPECVD.html"
  },"9": {
    "doc": "Advection Callback",
    "title": "Advection Callback",
    "content": ". Coming soon . ",
    "url": "/models/custom/advectionCallback.html",
    
    "relUrl": "/models/custom/advectionCallback.html"
  },"10": {
    "doc": "Anisotropic Process",
    "title": "Anisotropic Process",
    "content": "#include &lt;psAnisotropicProcess.hpp&gt; . ",
    "url": "/models/prebuilt/anisotropic.html",
    
    "relUrl": "/models/prebuilt/anisotropic.html"
  },"11": {
    "doc": "Anisotropic Process",
    "title": "Related Examples",
    "content": ". | Cantilever Wet Etching | Selective Epitaxy | . ",
    "url": "/models/prebuilt/anisotropic.html#related-examples",
    
    "relUrl": "/models/prebuilt/anisotropic.html#related-examples"
  },"12": {
    "doc": "Custom Geometry",
    "title": "Custom Geometry using ViennaLS",
    "content": ". ViennaPS offers the capability to create custom geometries using tools from the ViennaLS library. The viennals::MakeGeometry function provides functionality for constructing basic geometric shapes like boxes, spheres, or cylinders. Moreover, shapes can be formed by creating a convex hull over a point cloud or by explicitly defining points and elements of a structure. Subsequently, boolean operations such as union, intersect, and relative complement can be applied to merge these basic shapes into a customized geometry. This flexible approach enables users to create complex geometries tailored to their specific simulation requirements. ",
    "url": "/geo/custom.html#custom-geometry-using-viennals",
    
    "relUrl": "/geo/custom.html#custom-geometry-using-viennals"
  },"13": {
    "doc": "Custom Geometry",
    "title": "Custom Geometry",
    "content": " ",
    "url": "/geo/custom.html",
    
    "relUrl": "/geo/custom.html"
  },"14": {
    "doc": "Directional Process",
    "title": "Directional Process",
    "content": "#include &lt;psDirectionalProcess.hpp&gt; . The Directional Process Model simulates anisotropic material removal or deposition in semiconductor fabrication processes. It models etching where material removal occurs preferentially in a specified direction, influenced by both directional and isotropic velocity components. // namespace viennaps DirectionalProcess(const std::array&lt;NumericType, 3&gt; &amp;direction, NumericType directionalVelocity = 1., NumericType isotropicVelocity = 0., const Material mask = Material::Mask, bool calculateVisibility = true) DirectionalProcess(const Vec3D&lt;NumericType&gt; &amp;direction, NumericType directionalVelocity, NumericType isotropicVelocity = 0., const std::vector&lt;Material&gt; &amp;maskMaterials = std::vector&lt;Material&gt;{Material::Mask}, bool calculateVisibility = true) DirectionalProcess(const RateSet &amp;rateSet) . | Parameter | Description | Type | . | direction | Direction vector for directional process. | std::array&lt;NumericType, 3&gt; | . | directionalVelocity | (Optional) Velocity for directional process. | NumericType | . | isotropicVelocity | (Optional) Isotropic velocity. Default is set to 0. | NumericType | . | mask | (Optional) Material used as a mask. Default is set to Material::Mask. | Material | . | calculateVisibility | (Optional) Determines whether the process is limited by visibility constraints. Default is set to true. | bool | . A specialized direction can also specified using a RateSet with the following parameters: . | Parameter | Type | Description | . | direction | Vec3D&lt;NumericType&gt; | The preferred process direction. | . | directionalVelocity | NumericType | The etch rate along the specified direction. | . | isotropicVelocity | NumericType | Velocity applied isotropically. | . | maskMaterials | std::vector&lt;Material&gt; | List of materials used as a mask. | . | calculateVisibility | bool | Determines whether the process is limited by visibility constraints. | . Example usage: . C++ . // namespace viennaps RateSet&lt;NumericType&gt; rateSet; rateSet.direction = Vec3D&lt;NumericType&gt;{0., 0., 1.}; rateSet.directionalVelocity = 1.; rateSet.isotropicVelocity = 0.; rateSet.maskMaterials = {Material::Si, Material::SiO2}; rateSet.calculateVisibility = true; auto model = SmartPointer&lt;DirectionalProcess&lt;NumericType, D&gt;&gt;(rateSet); . Python . rateSet = vps.RateSet() rateSet.direction = [0., 0., 1.] rateSet.directionalVelocity = 1. rateSet.isotropicVelocity = 0. rateSet.maskMaterials = [vps.Material.Si, vps.Material.SiO2] rateSet.calculateVisibility = True model = vps.DirectionalProcess(rateSet) . ",
    "url": "/models/prebuilt/directional.html",
    
    "relUrl": "/models/prebuilt/directional.html"
  },"15": {
    "doc": "Geometry Extrusion",
    "title": "Extrude a Geometry from 2D to 3D",
    "content": ". Extrude a 2D domain into 3D, allowing users to define the extrusion direction and extent. Additionally, users have the flexibility to specify the boundary conditions for the extruded domain. Example usage: . C++ . ps::Extrude&lt;double&gt;(domain2D, domain3D, {0., 1.}, // min and max extent in the extruded dim 2, // extrude in z-direction {viennals::BoundaryConditionEnum::REFLECTIVE, viennals::BoundaryConditionEnum::REFLECTIVE, viennals::BoundaryConditionEnum::INFINITE_BOUNDARY}).apply(); . Since the ViennaPS 2D and 3D libraries cannot be used together in Python, this feature is currently not available in the Python bindings. ",
    "url": "/misc/extrusion.html#extrude-a-geometry-from-2d-to-3d",
    
    "relUrl": "/misc/extrusion.html#extrude-a-geometry-from-2d-to-3d"
  },"16": {
    "doc": "Geometry Extrusion",
    "title": "Geometry Extrusion",
    "content": " ",
    "url": "/misc/extrusion.html",
    
    "relUrl": "/misc/extrusion.html"
  },"17": {
    "doc": "Fin Geometry",
    "title": "Fin Geometry",
    "content": "#include &lt;geometries/psMakeFin.hpp&gt; . The MakeFin class generates a fin geometry extending in the z (3D) or y (2D) direction, centered at the origin with specified dimensions in the x and y directions. The fin may incorporate periodic boundaries in the x and y directions (limited to 3D). Users can define the width and height of the fin, and it can function as a mask, with the specified material exclusively applied to the bottom of the fin, while the upper portion adopts the mask material. // namespace viennaps // with DomainSetup configured (v3.3.0) MakeFin(DomainType domain, NumericType finWidth, NumericType finHeight, NumericType finTaperAngle, NumericType maskHeight = 0., NumericType maskTaperAngle = 0., bool halfFin = false, Material material = Material::Si, Material maskMaterial = Material::Mask) MakeFin(DomainType domain, const NumericType gridDelta, const NumericType xExtent, const NumericType yExtent, const NumericType finWidth, const NumericType finHeight, const NumericType baseHeight = 0., const bool periodicBoundary = false, const bool makeMask = false, const Material material = Material::Si) . | Parameter | Type | Description | Applicable Constructor | . | domain | psDomainType | The simulation domain. | Both | . | finWidth | NumericType | Width of the fin. | Both | . | finHeight | NumericType | Height of the fin. | Both (ignored if makeMask = true) | . | finTaperAngle | NumericType | Taper angle of the fin (default: 0.). | Both (ignored if makeMask = true) | . | maskHeight | NumericType | Height of the mask (default: 0.). | First constructor only | . | maskTaperAngle | NumericType | Taper angle of the mask (default: 0.). | First constructor only | . | halfFin | bool | If true, the fin is halved along the x-axis. | First constructor only | . | material | Material | Material of the fin (default: Material::Si). | Both | . | maskMaterial | Material | Material of the mask (default: Material::Mask). | First constructor only | . | gridDelta | NumericType | Grid spacing in the simulation domain. | Second constructor only | . | xExtent | NumericType | Extent of the domain in the x-direction. | Second constructor only | . | yExtent | NumericType | Extent of the domain in the y-direction. | Second constructor only | . | taperAngle | NumericType | Taper angle of the fin/mask. | Second constructor only | . | baseHeight | NumericType | Base height of the fin (default: 0.). | Second constructor only | . | periodicBoundary | bool | If true, enables periodic boundary conditions (default: false). | Second constructor only | . | makeMask | bool | If true, a mask is created instead of a fin (default: false). | Second constructor only | . Note: . | The first constructor requires that the domain is already configured and is only available from ViennaPS v3.3.0. | The second constructor allows domain setup within the constructor by specifying gridDelta, xExtent, and yExtent. | . Example usage: . C++ . // namespace viennaps // recomended with DomainSetup configured (v3.3.0) auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(0.5, 10., 10., BoundaryType::REFLECTIVE_BOUNDARY); MakeFin(domain, 2.5, 5.0, 10., 0., 0., false, Material::Si, Material::Mask).apply(); // without DomainSetup auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeFin&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5.0, 5.0, 0., false, false, Material::Si) .apply(); . Python: . # with DomainSetup configured (v3.3.0) domain = vps.Domain(0.5, 10., 10., vps.BoundaryType.REFLECTIVE_BOUNDARY) vps.MakeFin(domain=domain, finWidth=2.5, finHeight=5.0, finTaperAngle=10., maskHeight=5., maskTaperAngle=0., halfFin=False, material=vps.Material.Si, maskMaterial=vps.Material.Mask ).apply() # without DomainSetup domain = vps.Domain() vps.MakeFin(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, finWidth=2.5, finHeight=5.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/fin.html",
    
    "relUrl": "/geo/basic/fin.html"
  },"18": {
    "doc": "Fluorocarbon Etching",
    "title": "Fluorocarbon Etching",
    "content": "#include &lt;psFluorocarbonEtching.hpp&gt; . Our model assumes that, in any complex plasma etch process, there are four fundamental types of particles: neutral, etchant, depositing polymer particles and ions. Due to the long etch times, compared to surface reaction time scales, we can safely assume that each of these substances’ concentrations will reach a steady state on the surface. Therefore, the surface coverages of all involved particle types $\\phi_x$, where $x$ represents etchant (e), polymer (p), etchant on polymer (ep), and ions (i), are expressed by the following equations: \\begin{equation} \\frac{d \\phi_e}{dt}=J_{e} S_{e}\\left(1-\\phi_{e}-\\phi_{p}\\right)-k_{i e} J_{i} Y_{ie} \\phi_{e}-k_{e v} J_{e v} \\phi_{e} \\approx 0; \\end{equation} \\begin{equation} \\frac{d \\phi_{p}}{d t}=J_{p} S_{p}-J_{i} Y_{p} \\phi_{p} \\phi_{p e} \\approx 0; \\end{equation} \\begin{equation} \\frac{d \\phi_{p e}}{d t}=J_{e} S_{p e}\\left(1-\\phi_{p e}\\right)-J_{i} Y_{p} \\phi_{p e} \\approx 0. \\end{equation} Here, $J_x$ and $S_x$ represent the different particle fluxes and sticking probabilities, respectively. $Y_{ie}$ is the ion-enhanced etching yield for etchant particles, $Y_p$ is the ion-enhanced etching yield on polymer, $Y_{sp}$ gives the physical ion sputtering yield, and $k_{ie}$ and $k_{ev}$ are the stoichiometric factors for ion-enhanced etching and evaporation, respectively, which are determined by the chemical etching reaction. By solving these steady state equations for the coverages, one can determine etch or deposition rates on the surface. If deposition of polymer dominates, the surface normal velocity is positive and is given by \\begin{equation} v=\\frac{1}{\\rho_{p}}\\left(J_{p} S_{p}-Y_{p} J_{i} \\phi_{p e}\\right), \\end{equation} where $\\rho_p$ is the atomic polymer density. The first term $J_{p} S_{p}$ gives the rate of polymer particles reaching and adsorbing on the surface, while the second term $Y_{p} J_{i} \\phi_{p e}$ describes the removal of polymer by ion-enhanced etching. Together, these terms describe the deposition of polymer material on the surface, which acts as passivation layer for the chemical etching process. If, on the other hand, etching of the substrate dominates, the negative surface velocity of the substrate is given by \\begin{equation} v=\\frac{1}{\\rho_{m}}\\left[J_{e v} \\phi_{e}+J_{i} Y_{ie} \\phi_{e}+J_{i} Y_{sp}\\left(1-\\phi_{e}\\right)\\right], \\end{equation} where $\\rho_m$ is the atomic density of the etched material and depends on which layer in the stack is being etched. Each term accounts for a different type of surface reaction. The first term, $J_{e v} \\phi_{e}$, describes the chemical etching process, where etchants bind chemically with the substrate to form volatile etch products which dissolve thermally from the surface. Thus, the evaporation flux $J_{ev}$ is a parameter proportional to the etchant flux $J_e$ and depends on the chemical gas and surface composition and temperature of the etching plasma. It is given by \\begin{equation} J_{ev} = K e^{-E_a/k_B T}J_e, \\end{equation} where $K$ is a process parameter describing the volatility of the chemical etching process, $E_a$ is the activation energy for thermal etching, $k_B$ is the Boltzmann constant, and $T$ is the temperature. The second term, $J_{i} Y_{ie} \\phi_{e}$, describes the contribution of ion-enhanced etching. In this surface reaction, volatile etch products which do not dissolve from the surface thermally, absorb energy from impinging ions and consequently dissolve from the surface. Finally, the last term, $J_{i} Y_{sp}\\left(1-\\phi_{e}\\right)$, describes physical sputtering of the substrate by highly energetic ions. Since both chemical and ion-enhanced etching involve etchants, they are proportional to the etchant coverage $\\phi_e$, while physical ion sputtering takes place directly on the substrate and is thus proportional to the fraction of the surface not covered by the etchant. ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#fluorocarbon-etching",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#fluorocarbon-etching"
  },"19": {
    "doc": "Fluorocarbon Etching",
    "title": "Ions",
    "content": "Each ion is endowed with an initial energy and direction upon creation on the source plane. The assignment of initial energies is governed by a normal distribution, characterized by a mean energy value and an energy sigma, thus allowing for stochastic variations in the initial energy states of the ions. The distribution of initial ion directions is given by a power cosine source distribution, which is defined by the exponent of the power cosine distribution. Upon impact with the surface, an energy- and angle-dependent yield is computed, which contributes to the specific surface point’s rate. The yield is expressed as: \\begin{equation} Y(E,\\theta) = A\\left(\\sqrt{E} - \\sqrt{E_{th}}\\right)f(\\theta), \\end{equation} where $E$ denotes the particle energy and $\\theta$ its incident angle. Here, $A$ represents a yield coefficient, and $E_{\\text{th}}$ denotes the material’s threshold energy for physical sputtering. The function $f(\\theta)$, which characterizes the angle-dependence of the yield. For sputtering, the function is given by: \\begin{equation} f(\\theta) = (1 + B_{sp}(1-\\cos^2(\\theta)))\\cos(\\theta), \\end{equation} while for ion-enhanced etching, the function is given by: \\begin{equation} f(\\theta) = \\cos(\\theta). \\end{equation} . The ions can also reflect from the surface. Their energy loss during reflection is described by the model proposed by Belen et al [^1]. The current ray energy is multiplied by a factor $E_\\textrm{ref}$ ($0 \\leq E_\\textrm{ref} \\leq 1$) which depends on the incoming angle $\\theta$ in the following way: \\begin{equation} E_{\\textrm{ref}}= 1-(1-A)\\frac{\\frac{\\pi}{2}-\\theta}{\\frac{\\pi}{2}-\\theta_\\textrm{inflect}} \\quad \\text{ if } \\theta \\geqslant \\theta_\\textrm{inflect} \\end{equation} \\begin{equation} E_{\\textrm{ref}}=\\mathrm{A}\\left(\\frac{\\theta}{\\theta_\\textrm{inflect}}\\right)^{n_l} \\quad \\text{ if } \\theta&lt;\\theta_\\textrm{inflect}, \\end{equation} where $A = (1 + n(\\frac{\\pi}{2 \\theta_\\textrm{inflect}} - 1))^{-1}$. Ions striking the surface at an angle denoted by $\\theta$ relative to the surface normal undergo reflection, where the angular dispersion is characterized by a cosine function centered around the direction of specular reflection defined by $\\theta_\\textrm{spec}$. This reflection process distinguishes between ions approaching the surface at glancing angles, which undergo nearly perfect specular reflection, and those striking the surface perpendicularly, which undergo nearly diffuse reflection. \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{spec}}\\right) \\quad \\text{ if } \\theta_\\textrm{inc} \\leqslant \\theta_\\textrm{min} \\end{equation} . \\begin{equation} \\mathrm{P}(\\phi) \\propto \\cos \\left(\\frac{\\pi}{2} \\frac{\\phi}{\\frac{\\pi}{2}-\\theta_\\textrm{min}}\\right) \\quad \\text{ if } \\theta_{\\textrm{inc}}&gt;\\theta_{\\textrm{min}} \\end{equation} . The ray’s reflected direction is randomly chosen from a cone around the specular direction. The opening angle of this cone is given by the incidence angle $\\theta$. ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#ions",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#ions"
  },"20": {
    "doc": "Fluorocarbon Etching",
    "title": "Implementation",
    "content": "The fluorocarbon etching process is implemented in the psFluorocarbonEtching class. To customize the parameters of the process, it is advised to create a new instance of the class and set the desired parameters in the parameter struct. The following example demonstrates how to create a new instance of the class and set the parameters of the process. Time and length units have to be set before initializing the model. For details see Units. C++ . // namespace viennaps ... auto model = SmartPointer&lt;FluorocarbonEtching&lt;NumericType, D&gt;&gt;::New(); auto &amp;parameters = model-&gt;getParameters(); parameters.ionFlux = 10.; parameters.Mask.rho = 500.; // this modifies a direct reference of the parameters ... Python ... model = vps.FluorocarbonEtching() parameters = model.getParameters() parameters.ionFlux = 10. parameters.Mask.rho = 500. # this modifies a direct reference of the parameters ... The strcut holds the following parameters: . | Parameter | Description | Default Value | . | ionFlux | Ion flux (1015 /cm² /s) | 56.0 | . | etchantFlux | Etchant flux (1015 /cm² /s) | 500.0 | . | polyFlux | Polymer flux (1015 /cm² /s) | 100.0 | . | etchStopDepth | Depth at which etching stops | -inf | . | temperature | Temperature (K) | 300.0 | . | k_ie | Stoichiometric factor for ion enhanced etching | 2.0 | . | k_ev | Stoichiometric factor for chemical etching | 2.0 | . | beta_p | Polymer clean surface sticking probability | 0.26 | . | beta_e | Etchant clean surface sticking probability | 0.9 | . | beta_pe | Sticking probability for etchant on polymer | 0.6 | . | delta_p | Amount of polymer need to cause deposition of the surface | 1.0 | . | Mask.rho | Mask density (1022 atoms/cm³) | 500.0 | . | Mask.beta_p | Polymer clean surface sticking probability on mask material | 0.01 | . | Mask.beta_e | Etchant clean surface sticking probability on mask material | 0.1 | . | Mask.A_sp | Mask sputtering coefficient | 0.0139 | . | Mask.B_sp | Mask yield coefficient | 9.3 | . | Mask.Eth_sp | Mask sputtering threshold energy (eV) | 20.0 | . | SiO2.rho | SiO2 density (1022 atoms/cm³) | 2.2 | . | SiO2.Eth_sp | SiO2 sputtering threshold energy (eV) | 18.0 | . | SiO2.Eth_ie | SiO2 on enhanced etching threshold energy (eV) | 4.0 | . | SiO2.A_sp | SiO2 sputtering coefficient | 0.0139 | . | SiO2.B_sp | SiO2 yield coefficient | 9.3 | . | SiO2.A_ie | SiO2 ion enhanced etching coefficient | 0.0361 | . | SiO2.K | SiO2 volatility parameter in evaporation flux | 0.002789491704544977 | . | SiO2.E_a | SiO2 activation energy (eV) | 0.168 | . | Polymer.rho | Polymer density (1022 atoms/cm³) | 2.0 | . | Polymer.Eth_ie | Polymer ion enhanced etching threshold energy (eV) | 4.0 | . | Polymer.A_ie | Polymer ion enhanced etching coefficient | 0.1444 | . | Si3N4.rho | Si3N4 density (1022 atoms/cm³) | 2.3 | . | Si3N4.Eth_sp | Si3N4 sputtering threshold energy (eV) | 18.0 | . | Si3N4.Eth_ie | Si3N4 ion enhanced etching threshold energy (eV) | 4.0 | . | Si3N4.A_sp | Si3N4 sputtering coefficient | 0.0139 | . | Si3N4.B_sp | Si3N4 yield coefficient | 9.3 | . | Si3N4.A_ie | Si3N4 ion enhanced etching coefficient | 0.0361 | . | Si3N4.K | Si3N4 volatility parameter in evaporation flux | 0.002789491704544977 | . | Si3N4.E_a | Si3N4 activation energy (eV) | 0.168 | . | Si.rho | Si density (1022 atoms/cm³) | 5.02 | . | Si.Eth_sp | Si sputtering threshold energy (eV) | 20.0 | . | Si.Eth_ie | Si ion enhanced etching threshold energy (eV) | 4.0 | . | Si.A_sp | Si sputtering coefficient | 0.0337 | . | Si.B_sp | Si yield coefficient | 9.3 | . | Si.A_ie | Si ion enhanced etching coefficient | 0.0361 | . | Si.K | Si volatility parameter in evaporation flux | 0.029997010728956663 | . | Si.E_a | Si activation energy (eV) | 0.108 | . | Ions.meanEnergy | Mean ion energy (eV) | 100.0 | . | Ions.sigmaEnergy | Standard deviation of ion energy (eV) | 10.0 | . | Ions.exponent | Exponent of power cosine source distribution of initial ion directions | 500.0 | . | Ions.inflectAngle | Inflection angle | 1.55334303 | . | Ions.n_l | Exponent of reflection power | 10.0 | . | Ions.minAngle | Minimum cone angle for ion reflection | 1.3962634 | . ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#implementation",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#implementation"
  },"21": {
    "doc": "Fluorocarbon Etching",
    "title": "Related Examples",
    "content": ". | Stack Etching | . ",
    "url": "/models/prebuilt/fluorocarbonEtching.html#related-examples",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html#related-examples"
  },"22": {
    "doc": "Fluorocarbon Etching",
    "title": "Fluorocarbon Etching",
    "content": " ",
    "url": "/models/prebuilt/fluorocarbonEtching.html",
    
    "relUrl": "/models/prebuilt/fluorocarbonEtching.html"
  },"23": {
    "doc": "Member Functions",
    "title": "Domain Class Documentation",
    "content": ". ",
    "url": "/domain/functions.html#domain-class-documentation",
    
    "relUrl": "/domain/functions.html#domain-class-documentation"
  },"24": {
    "doc": "Member Functions",
    "title": "Constructors",
    "content": ". | Domain() – Default constructor | Domain(SmartPointer&lt;Domain&gt;) – Deep copy from another domain | Domain(lsDomainType) – Initialize from a single Level-Set | Domain(lsDomainsType) – Initialize from multiple Level-Sets | Domain(gridDelta, xExtent, yExtent = 0.0, boundary) – Rectangular grid initialization | Domain(bounds[], boundaryConditions[], gridDelta) – Bounding box initialization | Domain(const Setup &amp;setup) – From preconfigured domain setup | . ",
    "url": "/domain/functions.html#constructors",
    
    "relUrl": "/domain/functions.html#constructors"
  },"25": {
    "doc": "Member Functions",
    "title": "Key Member Functions",
    "content": "Domain Setup . void setup(const Setup &amp;setup); void setup(NumericType gridDelta, NumericType xExtent, NumericType yExtent = 0.0, BoundaryType boundary); . Initialize or reconfigure the simulation domain. Level-Set Management . void insertNextLevelSet(lsDomainType levelSet, bool wrap = true); void insertNextLevelSetAsMaterial(lsDomainType levelSet, Material material, bool wrap = true); void duplicateTopLevelSet(Material material); void removeTopLevelSet(); void removeLevelSet(unsigned int idx, bool removeWrapped = true); void removeMaterial(Material material); . Insert, duplicate, or remove Level-Sets. Materials can be assigned during insertion. Boolean Operations . void applyBooleanOperation(lsDomainType levelSet, viennals::BooleanOperationEnum op); . Apply a Boolean operation (e.g., union, intersection) across all Level-Sets in the domain. Cell-Set Generation . void generateCellSet(NumericType position, Material coverMaterial, bool isAboveSurface = false); . Convert Level-Set stack into a Cell-Set for volume process modeling. Material Mapping . void setMaterialMap(materialMapType map); void setMaterial(unsigned int lsId, Material material); . Assign or update material information for Level-Sets. Data Accessors . auto&amp; getSurface() const; auto&amp; getLevelSets() const; auto&amp; getMaterialMap() const; auto&amp; getCellSet() const; auto&amp; getGrid() const; auto getGridDelta() const; auto&amp; getSetup(); auto getBoundingBox() const; auto getBoundaryConditions() const; . Access the surface Level-Set, grid, bounding box, material map, and setup. Output &amp; Export . void saveLevelSetMesh(std::string fileName, int width = 1); void saveSurfaceMesh(std::string fileName, bool addMaterialIds = true); void saveVolumeMesh(std::string fileName, double wrappingEps = 1e-2) const; void saveHullMesh(std::string fileName, double wrappingEps = 1e-2) const; void saveLevelSets(std::string prefix) const; void print() const; . Save surface or volume meshes in VTK formats or print domain state to stdout. Utilities . void deepCopy(SmartPointer&lt;Domain&gt; other); void clear(); . Clone another domain or clear all internal data. ",
    "url": "/domain/functions.html#key-member-functions",
    
    "relUrl": "/domain/functions.html#key-member-functions"
  },"26": {
    "doc": "Member Functions",
    "title": "Notes",
    "content": ". | Level-Sets inserted with wrap = true are merged with underlying layers. | Material IDs are stored under the \"MaterialIds\" label in exported meshes. | Cell-Sets are not automatically generated and must be explicitly created using generateCellSet. | . ",
    "url": "/domain/functions.html#notes",
    
    "relUrl": "/domain/functions.html#notes"
  },"27": {
    "doc": "Member Functions",
    "title": "Example Usage",
    "content": "using DomainType = viennaps::Domain&lt;double, 3&gt;; auto domain = DomainType::New(1.0, 10.0, 10.0); auto ls = viennals::Domain&lt;double, 3&gt;::New(); // setup ls... domain-&gt;insertNextLevelSetAsMaterial(ls, Material::Si); domain-&gt;saveSurfaceMesh(\"surface.vtp\"); . ",
    "url": "/domain/functions.html#example-usage",
    
    "relUrl": "/domain/functions.html#example-usage"
  },"28": {
    "doc": "Member Functions",
    "title": "See Also",
    "content": ". | ViennaLS Documentation | . ",
    "url": "/domain/functions.html#see-also",
    
    "relUrl": "/domain/functions.html#see-also"
  },"29": {
    "doc": "Member Functions",
    "title": "Member Functions",
    "content": " ",
    "url": "/domain/functions.html",
    
    "relUrl": "/domain/functions.html"
  },"30": {
    "doc": "GDS File Import",
    "title": "Importing a GDSII Mask File",
    "content": ". ViennaPS provides a convenient feature allowing users to import geometries directly from GDSII mask files. It’s important to note that ViennaPS focuses on handling simple geometry information extracted from GDSII files, without supporting additional data that might be stored within the GDSII format. To parse a GDSII file using ViennaPS, follow these steps: . | Create a ps::GDSGeometry Object: Initialize a ps::GDSGeometry object, specifying the desired grid spacing, boundary conditions, and additional padding (optional). auto mask = ps::SmartPointer&lt;ps::GDSGeometry&lt;NumericType, D&gt;&gt;::New(); mask-&gt;setGridDelta(gridDelta); mask-&gt;setBoundaryConditions(boundaryConds); mask-&gt;setBoundaryPadding(xPad, yPad); . Replace gridDelta, boundaryConds, and xPad,yPad with your preferred values. The geometry is always parsed on a plane normal to the z direction. The values of xPad and yPad are always added to the largest and subtracted from the smallest extension of all geometries in the GDSII file. | Use ps::GDSReader to Parse Geometry: Utilize the ps::GDSReader to parse the GDSII file into the previously created ps::GDSGeometry object. ps::GDSReader&lt;NumericType, D&gt;(mask, \"path/to/your/file.gds\").apply(); . Replace \"path/to/your/file.gds\" with the actual path to your GDSII file. | Convert Single Layers to Level Sets: Extract specific layers from the parsed GDSII geometry, convert them into level sets, and add them to your simulation domain. To access a particular layer, provide its GDSII layer number. // Create new domain auto domain = ps::SmartPointer&lt;ps::Domain&lt;NumericType, D&gt;&gt;::New(); // Convert the layer to a level set and add it to the domain. auto layer = mask-&gt;layerToLevelSet(0 /*layer*/, 0 /*base z position*/, 0.5 /*height*/); domain-&gt;insertNextLevelSet(layer); . Replace layerNumber with the GDSII layer number you wish to access. Layers can also be inverted to be used a mask. // Create new domain auto domain = ps::SmartPointer&lt;ps::Domain&lt;NumericType, D&gt;&gt;::New(); // Convert the inverted layer to a level set and add it to the domain. auto layer = mask-&gt;layerToLevelSet(0 /*layer*/, 0 /*base z position*/, 0.5 /*height*/, true /*invert*/); domain-&gt;insertNextLevelSetAsMaterial(layer, ps::Material::Mask); // Create substrate underneath the mask ps::MakePlane&lt;NumericType, D&gt;(domain, 0. /*base z position*/, ps::Material::Si).apply(); . | . ",
    "url": "/geo/gdsimport.html#importing-a-gdsii-mask-file",
    
    "relUrl": "/geo/gdsimport.html#importing-a-gdsii-mask-file"
  },"31": {
    "doc": "GDS File Import",
    "title": "Related Examples",
    "content": ". | GDS Reader | . ",
    "url": "/geo/gdsimport.html#related-examples",
    
    "relUrl": "/geo/gdsimport.html#related-examples"
  },"32": {
    "doc": "GDS File Import",
    "title": "GDS File Import",
    "content": " ",
    "url": "/geo/gdsimport.html",
    
    "relUrl": "/geo/gdsimport.html"
  },"33": {
    "doc": "GPU Module",
    "title": "Installing the GPU Module",
    "content": ". The GPU ray tracing module is still an experimental feature and is under active development. If you encounter any issues or have suggestions, please let us know on GitHub. ",
    "url": "/inst/gpu.html#installing-the-gpu-module",
    
    "relUrl": "/inst/gpu.html#installing-the-gpu-module"
  },"34": {
    "doc": "GPU Module",
    "title": "Requirements",
    "content": "The GPU ray tracing module is implemented using OptiX 8.0. To use it, ensure your system meets the following requirements: . | NVIDIA Driver: Version 550 or higher | CUDA Toolkit: Version 12.0 | OptiX SDK: Version 8.0 | GCC: Version 12.0 | . ViennaPS depends on ViennaLS. When building ViennaPS locally (especially with GPU support), you must also build ViennaLS locally from the same source. Using the PyPI version of ViennaLS is not compatible with a local ViennaPS build. ",
    "url": "/inst/gpu.html#requirements",
    
    "relUrl": "/inst/gpu.html#requirements"
  },"35": {
    "doc": "GPU Module",
    "title": "Python Bindngs Scripts",
    "content": "To make installation easier, we provide two setup scripts: . 1. install_ViennaPS_linux.sh . | Compatibility: All Linux distributions | Functionality: . | Builds and installs ViennaPS locally | Checks for an existing local build of ViennaLS | . | Limitations: . | Assumes you have already installed dependencies like VTK and embree manually | . | . 2. install_ViennaTools_ubuntu.sh . | Compatibility: Ubuntu 24.04 only | Functionality: . | Installs all required dependencies: VTK, embree, and others using apt | Builds and installs ViennaLS and ViennaPS in a local folder named ViennaTools | Suitable for a fresh installation on Ubuntu systems | . | Advantages: . | Fully automated setup including all system dependencies | Ideal for users new to the ViennaTools ecosystem | . | . ",
    "url": "/inst/gpu.html#python-bindngs-scripts",
    
    "relUrl": "/inst/gpu.html#python-bindngs-scripts"
  },"36": {
    "doc": "GPU Module",
    "title": "CMake Configuration",
    "content": "To enable GPU support, follow these steps: . | Run CMake with the -DVIENNAPS_USE_GPU=ON option to enable GPU support. | Specify the path to your OptiX installation by setting the CMake variable OptiX_INSTALL_DIR. | This should point to the directory where the include folder containing OptiX headers is located. E.g.: cmake -DVIENNAPS_USE_GPU=ON -DOptiX_INSTALL_DIR=/path/to/optix . Alternatively, you can set the OptiX_INSTALL_DIR environment variable: . export OptiX_INSTALL_DIR=/path/to/optix . This will be used during the CMake setup. | . | Install the CUDA toolkit system-wide so CMake can detect it automatically or provide CUDA_PATH CMake variable. | Run CMake configuration. If both CUDA and OptiX are found, the GPU extension will be enabled. | (Optional) To build examples or tests, set: . | VIENNAPS_BUILD_EXAMPLES=ON | VIENNAPS_BUILD_TESTS=ON | . | . ",
    "url": "/inst/gpu.html#cmake-configuration",
    
    "relUrl": "/inst/gpu.html#cmake-configuration"
  },"37": {
    "doc": "GPU Module",
    "title": "Python Build Instructions",
    "content": "For building the Python GPU module: . | Set the environment variable OptiX_INSTALL_DIR to the OptiX installation directory. | This variable will be used during the CMake setup. | . | Run the following command to install the module locally: CMAKE_ARGS=-DVIENNAPS_USE_GPU=ON pip install . | The GPU functions are available in the GPU submodule: import viennaps3d as vps context = vps.gpu.Context() context.create() gpuProcess = vps.gpu.Process(context) . Note: The GPU submodule is only available in the 3D bindings since GPU ray tracing is implemented for 3D only. | . Example usage of the GPU module can be found in the examples. Currently, only a limited number of models are available for GPU acceleration: SingleParticleProcess, MultiParticleProcess, and SF6O2Etching. ",
    "url": "/inst/gpu.html#python-build-instructions",
    
    "relUrl": "/inst/gpu.html#python-build-instructions"
  },"38": {
    "doc": "GPU Module",
    "title": "GPU Module",
    "content": " ",
    "url": "/inst/gpu.html",
    
    "relUrl": "/inst/gpu.html"
  },"39": {
    "doc": "Hole Geometry",
    "title": "Hole Geometry",
    "content": "#include &lt;geometries/psMakeHole.hpp&gt; . The MakeHole class generates a hole geometry in the z direction, which, in 2D mode, corresponds to a trench geometry. Positioned at the origin, the hole is centered, with the total extent defined in the x and y directions. The normal direction for the hole creation is in the positive z direction in 3D and the positive y direction in 2D. Users can specify the hole’s radius, depth, and opt for tapering with a designated angle. The hole configuration may include periodic boundaries in both the x and y directions. Additionally, the hole can serve as a mask, with the specified material only applied to the bottom of the hole, while the remainder adopts the mask material. // namespace viennaps // with DomainSetup configured (v3.3.0) MakeHole(psDomainType domain, NumericType holeRadius, NumericType holeDepth, NumericType holeTaperAngle = 0., NumericType maskHeight = 0., NumericType maskTaperAngle = 0., HoleShape shape = HoleShape::Full, Material material = Material::Si, Material maskMaterial = Material::Mask) MakeHole(DomainType domain, NumericType gridDelta, NumericType xExtent, NumericType yExtent, NumericType holeRadius, NumericType holeDepth, NumericType taperAngle = 0., // in degrees NumericType baseHeight = 0., bool periodicBoundary = false, bool makeMask = false, Material material = Material::Si, HoleShape holeShape = HoleShape::Full) . | Parameter | Type | Description | Applicable Constructor | . | domain | psDomainType | The simulation domain. | Both | . | holeRadius | NumericType | Radius of the hole. | Both | . | holeDepth | NumericType | Depth of the hole. | Both | . | holeTaperAngle | NumericType | Taper angle of the hole (default: 0.). | Both | . | maskHeight | NumericType | Height of the masking layer (default: 0.). | First constructor only | . | maskTaperAngle | NumericType | Taper angle of the masking layer (default: 0.). | First constructor only | . | shape | HoleShape | Shape of the hole (default: HoleShape::Full). | Both | . | material | Material | Material of the hole (default: Material::Si). | Both | . | maskMaterial | Material | Material of the mask (default: Material::Mask). | First constructor only | . | gridDelta | NumericType | Grid spacing in the simulation domain. | Second constructor only | . | xExtent | NumericType | Extent of the domain in the x-direction. | Second constructor only | . | yExtent | NumericType | Extent of the domain in the y-direction. | Second constructor only | . | taperAngle | NumericType | Alternative name for holeTaperAngle in the second constructor (default: 0.). | Second constructor only | . | baseHeight | NumericType | Height at which the hole starts (default: 0.). | Second constructor only | . | periodicBoundary | bool | If true, enables periodic boundary conditions (default: false). | Second constructor only | . | makeMask | bool | If true, the mask is created instead of the hole, setting holeDepth to 0 (default: false). | Second constructor only | . Note: . | The first constructor requires that the domain is already configured. | The second constructor sets up a new simulation domain with gridDelta, xExtent, and yExtent. | If makeMask is true, the hole is not created, and only the masking layer is applied. | . Example usage: . C++ . // namespace viennaps // with DomainSetup configured (v3.3.0) auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(0.5, 10., 10., BoundaryType::REFLECTIVE_BOUNDARY); MakeHole&lt;NumericType, D&gt;(domain, 5.0, 5.0, 10., 0., 0., HoleShape::Quarter, Material::Si, Material::Mask) .apply(); // without DomainSetup auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeHole&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 2.5, 5.0, 10., 0., false, false, Material::Si) .apply(); . Python . # with DomainSetup configured (v3.3.0) domain = vps.Domain(gridDelta=0.5, xExtent=10.0, yExtent=10.0, boundaryType=vps.BoundaryType.REFLECTIVE_BOUNDARY) vps.MakeHole(domain=domain, holeRadius=5.0, holeDepth=0.0, holeTaperAngle=0.0, maskHeight=5.0, maskTaperAngle=2.0, shape=vps.HoleShape.Quarter, material=vps.Material.Si, maskMaterial=vps.Material.Mask ).apply() domain = vps.Domain() vps.MakeHole(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, holeRadius=2.5, holeDepth=5.0, taperingAngle=10.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, holeShape=vps.HoleShape.Quarter ).apply() . ",
    "url": "/geo/basic/hole.html",
    
    "relUrl": "/geo/basic/hole.html"
  },"40": {
    "doc": "Miscellaneous",
    "title": "Miscellaneous",
    "content": " ",
    "url": "/misc/",
    
    "relUrl": "/misc/"
  },"41": {
    "doc": "Examples",
    "title": "Examples",
    "content": ". ",
    "url": "/examples/#examples",
    
    "relUrl": "/examples/#examples"
  },"42": {
    "doc": "Examples",
    "title": "Building",
    "content": "The examples can be built using CMake: . git clone https://github.com/ViennaTools/ViennaPS.git cd ViennaPS cmake -B build -DVIENNAPS_BUILD_EXAMPLES=ON cmake --build build . The examples can then be executed in their respective build folders with the config files, e.g.: . cd examples/exampleName ./ExampleName.bat config.txt # (Windows) ./ExampleName config.txt # (Other) . Individual examples can also be build by calling make in their respective build folder. An equivalent Python script, using the ViennaPS Python bindings, is also given for most examples. ",
    "url": "/examples/#building",
    
    "relUrl": "/examples/#building"
  },"43": {
    "doc": "Examples",
    "title": "Examples",
    "content": "| Atomic Layer Deposition | Blazed Gratings Etching | . | Bosch Process | Cantilever Wet Etching | . | Emulation | DRAM Wiggling | . | Faraday Cage Etching | Hole Etching | . | Ion Beam Etching | Selective Epitaxy | . | Sputter Deposition | Stack Etching | . | TEOS Trench Deposition | Trench Deposition | . More Examples: . | Custom Example Process | GDS Reader | Interpolation Demo | Oxide Regrowth | SiGe Selective Etching | Trench Deposition Geometric | . ",
    "url": "/examples/#examples-1",
    
    "relUrl": "/examples/#examples-1"
  },"44": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "/examples/",
    
    "relUrl": "/examples/"
  },"45": {
    "doc": "Geometry Builders",
    "title": "Basic Geometry Builders",
    "content": ". ViennaPS provides a set of functions to effortlessly create basic geometries, facilitating quick testing of models or serving as the groundwork for your process simulation configuration. The various available geometries are outlined below: . ",
    "url": "/geo/basic/#basic-geometry-builders",
    
    "relUrl": "/geo/basic/#basic-geometry-builders"
  },"46": {
    "doc": "Geometry Builders",
    "title": "Geometry Builders",
    "content": " ",
    "url": "/geo/basic/",
    
    "relUrl": "/geo/basic/"
  },"47": {
    "doc": "Creating a Geometry",
    "title": "Creating a Geometry",
    "content": ". Create custom geometries using the versatile tools offered by ViennaLS or generate a basic geometry (plane, hole, trench, fin, stack) using one of the provided geometry builders. Alternatively, you can import a geometry from a GDSII mask file. ",
    "url": "/geo/",
    
    "relUrl": "/geo/"
  },"48": {
    "doc": "Geometry Output",
    "title": "Geometry Output",
    "content": ". ViennaPS provides various methods for outputting the surface or volume of the processed domain. The data is typically saved in the VTK file format, with surfaces stored in .vtp files and volumes in .vtu files. For visualization, we recommend using ParaView, a powerful open-source visualization tool. Below, you’ll find further details on the available geometry outputs. In addition to VTK file formats, ViennaPS provides the flexibility to store level sets directly in the proprietary .lvst format. This feature enables users to save intermediate states during the process, allowing for more detailed analysis and the ability to revisit specific simulation stages. ",
    "url": "/output/",
    
    "relUrl": "/output/"
  },"49": {
    "doc": "Pre-Built Models",
    "title": "Pre-Built Models",
    "content": " ",
    "url": "/models/prebuilt/",
    
    "relUrl": "/models/prebuilt/"
  },"50": {
    "doc": "Custom Models",
    "title": "Custom Models",
    "content": ". Users can create a custom process model by interfacing one or more of the classes described below and then inserting them into their custom process model. | The SurfaceModel class is used to describe surface reactions, combining particle fluxes with the surface chemical reactions. | The VelocityField provides the interface between surface velocities and the advection kernel to integrate the Level-Set equation in a time step. | ViennaPS seamlessly integrates ViennaRay functionality through the viennaray::Particle class, providing users with a versatile interface to define the key characteristics of the simulated particle species. | . Custom model building is only available in the C++ interface. ",
    "url": "/models/custom/",
    
    "relUrl": "/models/custom/"
  },"51": {
    "doc": "Process Models",
    "title": "Process Models",
    "content": "#include &lt;psProcessModel.hpp&gt; . All the information about the process is encompassed in the class ProcessModel, as it includes all the particle type information required for ray tracing, the surface model, as well as advection callbacks, for generating volume models describing chemical processes inside the material. Users have the flexibility to configure their own custom process model or opt for pre-defined models encompassing frequently used processes. ",
    "url": "/models/",
    
    "relUrl": "/models/"
  },"52": {
    "doc": "General Notes",
    "title": "General Notes",
    "content": ". ",
    "url": "/general/",
    
    "relUrl": "/general/"
  },"53": {
    "doc": "General Notes",
    "title": "Namespace",
    "content": "ViennaPS is encapsulated within the viennaps namespace. This design choice ensures that all classes, functions, and utilities within the library are organized under a single namespace, providing a clean and structured interface for users. When working with ViennaPS, it is essential to include the viennaps namespace in your code to access the library’s functionality. In this documentation, the namespace is omitted for brevity, but it should be included in your code. ",
    "url": "/general/#namespace",
    
    "relUrl": "/general/#namespace"
  },"54": {
    "doc": "General Notes",
    "title": "Numeric Types",
    "content": "ViennaPS supports the utilization of either float or double as the underlying numeric type. While float might offer slightly higher performance in some cases, it is generally recommended to use double in your simulation due to its enhanced precision. It’s essential to note that the choice of numeric type is a static (compile-time) parameter in every ViennaPS class and function. Once a numeric type is selected for a particular simulation, it is not possible to switch to a different numeric type within the program. Additionally, for users working with Python bindings, it’s important to be aware that the Python interface always uses double as the numeric type. ",
    "url": "/general/#numeric-types",
    
    "relUrl": "/general/#numeric-types"
  },"55": {
    "doc": "General Notes",
    "title": "Switching between 2D and 3D mode",
    "content": "ViennaPS provides the flexibility for users to choose between 2D and 3D modes during compile time. The dimensionality is specified as a second template (static) parameter, and most classes and functions in ViennaPS adhere to this structure. It’s important to note that 2D and 3D classes cannot be mixed within the same simulation, and the choice of dimensionality is fixed at compile time. For users who need to transition from a 2D to a 3D simulation, ViennaPS offers the Extrude utility. This utility enables the extrusion of a 2D domain to 3D, providing a seamless way to extend simulations across different dimensions. ",
    "url": "/general/#switching-between-2d-and-3d-mode",
    
    "relUrl": "/general/#switching-between-2d-and-3d-mode"
  },"56": {
    "doc": "General Notes",
    "title": "Using Smart Pointers",
    "content": "In ViennaPS, smart pointers are utilized to pass domains, models, and other essential objects to processes and utility functions. To facilitate this, the library includes a custom class named SmartPointer, serving as a shared pointer implementation. This design choice ensures efficient memory management and enables seamless interaction between different components within the simulation framework. Example: . // Creating a new domain auto domain = psSmartPointer&lt;psDomain&lt;NumericType, D&gt;&gt;::New(); // Using a pre-built model auto model = psSmartPointer&lt;psIsotropicProcess&lt;NumericType, D&gt;&gt;::New(/*pass constructor arguments*/); . ",
    "url": "/general/#using-smart-pointers",
    
    "relUrl": "/general/#using-smart-pointers"
  },"57": {
    "doc": "Running a Process",
    "title": "Running a Process",
    "content": "#include &lt;psProcess.hpp&gt; . The Process class functions as the primary simulation interface, consolidating crucial elements such as the simulation domain, process model, process duration, and requisite ray-tracing parameters. This interface also contains the necessary methods for configuring these attributes. Upon setting these parameters, the apply() method is employed to execute the process,. Example usage: . C++ . // namespace viennaps ... Process&lt;NumericType, D&gt; process; process.setDomain(myDomain); process.setProcessModel(myModel); process.setProcessDuration(10.); process.apply(); ... Python ... process = vps.Process() process.setDomain(myDomain) process.setProcessModel(myModel) process.setProcessDuration(10.) process.apply() ... ",
    "url": "/process/",
    
    "relUrl": "/process/"
  },"58": {
    "doc": "Running a Process",
    "title": "Process Parameters",
    "content": "Advanced process parameters, as described in this section are available from version 3.3.0 . Expert users can set specific parameter for the Level-Set integration and Ray Tracing flux calculation steps using the advanced parameters structs AdvectionParameters and RayTracingParameters. These parameter structs contain: . AdvectionParameters: . | Parameter | Type | Default Value | Description | . | integrationScheme | IntegrationSchemeEnum | ENGQUIST_OSHER_1ST_ORDER | Integration scheme used for advection. For options see here. | . | timeStepRatio | NumericType | 0.4999 | Ratio controlling the time step specified by the CFL condition. More details | . | dissipationAlpha | NumericType | 1.0 | Factor controlling dissipation in Lax-Friedrichs type integration schemes. | . | velocityOutput | bool | false | Whether to output velocity data for each advection step. | . | ignoreVoids | bool | false | Whether to ignore void regions. | . RayTracingParameters: . | Parameter | Type | Default Value | Description | . | sourceDirection | TraceDirection | POS_Z (if D == 3), POS_Y (otherwise) | Direction of the ray source. | . | normalizationType | NormalizationType | SOURCE | Type of normalization used. Other option MAX. | . | raysPerPoint | unsigned | 1000 | Number of rays to trace per point in the geometry. | . | diskRadius | NumericType | 0 | Radius of the disks in the ray tracing geometry. If this value is 0 the default disk radius is used, which is the minimum radius such that there are no holes in the geometry. | . | useRandomSeeds | bool | true | Whether to use random seeds. | . | ignoreFluxBoundaries | bool | false | Whether to ignore boundary condtions during ray tracing. | . | smoothingNeighbors | int | 1 | Number of neighboring points used for smoothing the flux after ray tracing. | . Example usage: . C++ . // namespace viennaps ... AdvectionParameters&lt;NumericType&gt; advParams; advParams.integrationScheme = viennals::IntegrationSchemeEnum::LOCAL_LAX_FRIEDRICHS_2ND_ORDER advParams.timeStepRatio = 0.25 advParams.dissipationAlpha = 2.0 RayTracingParameters&lt;NumericType, D&gt; tracingParams; tracingParams.raysPerPoint = 500 tracingParams.smoothingNeighbors = 0 // disable flux smoothing Process&lt;NumericType, D&gt; process(myDomain, myModel, duration); process.setAdvectionParameters(advParams) process.setRayTracingParameters(tracingParams) process.apply(); ... Python ... advParams = vps.AdvectionParameters() advParams.integrationScheme = vps.ls.IntegrationSchemeEnum.LOCAL_LAX_FRIEDRICHS_2ND_ORDER advParams.timeStepRatio = 0.25 advParams.dissipationAlpha = 2.0 tracingParams = vps.RayTracingParameters() tracingParams.raysPerPoint = 500 tracingParams.smoothingNeighbors = 0 # disable flux smoothing process = vps.Process(myDomain, myModel, duration) process.setAdvectionParameters(advParams) process.setRayTracingParameters(tracingParams) process.apply() ... ",
    "url": "/process/#process-parameters",
    
    "relUrl": "/process/#process-parameters"
  },"59": {
    "doc": "Running a Process",
    "title": "Member Functions",
    "content": "Constructors . // Default constructor Process() // Constructor from domain Process(SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt; passedDomain) // Constructor from domain, process model, and duration, // to apply simple processes template &lt;typename ProcessModelType&gt; Process(SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt; passedDomain, SmartPointer&lt;ProcessModelType&gt; passedProcessModel, const NumericType passedDuration = 0.) . In summary, these constructors provide different ways to create a Process object, allowing for flexibility depending on what data is available at the time of object creation. | The first constructor is a default constructor. It’s defined as Process() and it doesn’t take any arguments. This constructor allows for the creation of a Process object without any initial values. | The second constructor takes a single argument: a smart pointer to a Domain object. This constructor initializes the domain member variable of the Process class with the passed Domain object. | The third constructor is a template constructor that takes three arguments: a smart pointer to a Domain object, a smart pointer to a ProcessModelType object, and a NumericType representing the process duration. This constructor initializes the domain and processDuration member variables with the passed values and also sets the model member variable to the dynamically cast ProcessModelType object. This allows the user to run a process from an anonymous object. For example: Process&lt;NumericType, D&gt;(myDomain, myModel, processDuration).apply() . | . Set the domain . void setDomain(SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt; passedDomain) . Sets the process domain. Set the process model . void setProcessModel(SmartPointer&lt;ProcessModel&lt;NumericType, D&gt;&gt; passedProcessModel) . Sets the process model. This can be either a pre-configured process model or a custom process model. Set the source direction . void setSourceDirection(const viennaray::TraceDirection passedDirection) . Set the source direction, where the rays should be traced from. The passed direction parameter is using the enum viennaray::TraceDirection which contains the following values: POS_X, NEG_X, POS_Y, NEG_Y, POS_Z, NEG_Z. Set the process duration . void setProcessDuration(NumericType passedDuration) . Specifies the duration of the process. If the process duration is set to 0, exclusively the advection callback applyPreAdvect() is executed on the domain. This feature is particularly useful for applying only a volume model without engaging in further simulation steps. Single-Pass Flux Calculation . SmartPointer&lt;viennals::Mesh&lt;NumericType&gt;&gt; calculateFlux() . Calculate the flux(es) for the current process. This function returns a smart pointer to a viennals::Mesh&lt;NumericType&gt; object containing the disk mesh and flux data. Set the number of coverage initialization iterations . void setMaxCoverageInitIterations(unsigned numIter) . Set the maximum number of iterations to initialize the coverages. If additionally the coverage delta threshold is set, the coverage initialization is considered converged if the coverage delta is below the threshold or the maximum number of iterations is reached. Set coverage delta threshold . void setCoverageDeltaThreshold(NumericType threshold) . Set the threshold for the coverage delta metric to reach convergence. If the coverage delta is below this threshold, the coverage initialization is considered converged. During a process, if the coverage delta is higher than this threshold, the flux calculation is repeated. Set the advection parameters . void setAdvectionParameters(const AdvectionParameters&lt;NumericType&gt;&amp; passedAdvectionParameters) . Set the advection parameters for the level-set integration. The advection parameters are defined in the AdvectionParameters struct. Set the ray tracing parameters . void setRayTracingParameters(const RayTracingParameters&lt;NumericType, D&gt;&amp; passedRayTracingParameters) . Set the ray tracing parameters for the flux calculation. The ray tracing parameters are defined in the RayTracingParameters struct. The following functions are used to set parameters in the AdvectionParameters and RayTracingParameters structs. From version 3.3.0, it is recommended to use the setAdvectionParameters and setRayTracingParameters functions to set these parameters. Set the number of rays to be traced . void setNumberOfRaysPerPoint(unsigned raysPerPoint) . Specify the number of rays to be traced for each particle throughout the process. The total count of rays is the product of this number and the number of points in the process geometry. Enable or disable flux smoothing . void enableFluxSmoothing() void disableFluxSmoothing() . Toggle the option to enable or disable flux smoothing. When flux smoothing is activated, the flux at each surface point, computed by the ray tracer, undergoes averaging across the neighboring surface points. Per default, flux smoothing is enabled. Enable or disable flux boundary conditions . void enableFluxBoundaries() void disableFluxBoundaries() . Toggle the option to enable or disable flux boundary conditions. When flux boundary conditions are disabled, particles are allowed to leave the domain without being reflected back into the domain. Per default, flux boundary conditions are enabled. Enable or disable random seeds . void enableRandomSeeds() void disableRandomSeeds() . Toggle the option to enable or disable random seeds. When random seeds are enabled, the random number generator is seeded with a random value, making the results generally not perfectly reproducible. Per default, random seeds are enabled. Set the integration scheme . void setIntegrationScheme(lsIntegrationSchemeEnum passedIntegrationScheme) . Set the integration scheme for solving the level-set equation. Possible integration schemes are specified in viennals::IntegrationSchemeEnum. Set the time step ratio . void setTimeStepRatio(NumericType cfl) . Set the CFL (Courant-Friedrichs-Levy) condition to use during surface advection in the level-set. The CFL condition defines the maximum distance a surface is allowed to move in a single advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999. ",
    "url": "/process/#member-functions",
    
    "relUrl": "/process/#member-functions"
  },"60": {
    "doc": "Dependencies",
    "title": "Dependencies",
    "content": ". ",
    "url": "/deps/",
    
    "relUrl": "/deps/"
  },"61": {
    "doc": "Dependencies",
    "title": "ViennaLS",
    "content": "ViennaLS forms the foundation of the process simulator, applying the level-set surface representation concepts for topography simulations. This module not only stores the level-set surface but also encompasses essential algorithms for geometry initialization, level-set value manipulation based on a velocity field, surface feature analysis, and seamless conversion of the level-set representation to other commonly employed material representations in device simulators. ",
    "url": "/deps/#viennals",
    
    "relUrl": "/deps/#viennals"
  },"62": {
    "doc": "Dependencies",
    "title": "ViennaRay",
    "content": "ViennaPS relies on ViennaRay, a top-down Monte Carlo flux calculation library, to carry out essential flux calculations. This library is built upon Intel®’s ray tracing kernel, Embree. Crafted with a focus on efficiency and high-performance ray tracing, ViennaRay ensures a seamless user experience through its straightforward and user-friendly interface. In the top-down Monte Carlo approach, a large number of pseudo-particles are launched from a source plane situated above the surface, and their points of impact on the surface are determined. These pseudo-particles are initialized with a uniform initial position on the source plane and an initial direction that follows a power-cosine distribution. Each pseudo-particle carries a specific payload, representing a fraction of the total source flux. Upon reaching the surface, the current payload of the pseudo-particle contributes to the flux at that particular surface location. Furthermore, pseudo-particles have the capability to undergo reflection from the surface. The payload of a pseudo-particle undergoes reduction by the sticking coefficient during reflection. As a result, a pseudo-particle is tracked until its payload falls below a certain threshold or until it exits the simulation domain. This tracking mechanism provides a comprehensive understanding of the particle dynamics during its interaction with the sample surface. ",
    "url": "/deps/#viennaray",
    
    "relUrl": "/deps/#viennaray"
  },"63": {
    "doc": "Simulation Domain",
    "title": "Simulation Domain",
    "content": "#include &lt;psDomain.hpp&gt; . In our simulation framework, the essential hub for all geometry details is the Domain class. This class is like a smart keeper of information, holding everything about the materials in the simulation domain. It uses level sets to show surfaces and material interfaces with great detail and organizes data in a cell-based structure for the underlying volumes. Depending on the specific process, it can use one or both of these methods. This flexibility ensures that the simulation can handle different processes accurately and efficiently. ",
    "url": "/domain/",
    
    "relUrl": "/domain/"
  },"64": {
    "doc": "Installing the Library",
    "title": "Installing the Library",
    "content": ". ",
    "url": "/inst/",
    
    "relUrl": "/inst/"
  },"65": {
    "doc": "Installing the Library",
    "title": "Quick Start",
    "content": "To install ViennaPS for Python, simply run: . pip install ViennaPS . If there is no pre-built package available for your operating system, you can build the package yourself using the instructions below. To use ViennaPS in C++, clone the repository and follow the installation steps below. ",
    "url": "/inst/#quick-start",
    
    "relUrl": "/inst/#quick-start"
  },"66": {
    "doc": "Installing the Library",
    "title": "Supported Operating Systems",
    "content": ". | Windows (Visual Studio) . | Linux (g++ / clang) . | macOS (XCode) . | . ",
    "url": "/inst/#supported-operating-systems",
    
    "relUrl": "/inst/#supported-operating-systems"
  },"67": {
    "doc": "Installing the Library",
    "title": "System Requirements",
    "content": ". | C++17 Compiler with OpenMP support | . ",
    "url": "/inst/#system-requirements",
    
    "relUrl": "/inst/#system-requirements"
  },"68": {
    "doc": "Installing the Library",
    "title": "Installing",
    "content": "ViennaLS uses VTK as dependency which can be installed beforehand to save some time when building the dependencies. On Linux based systems, it can be installed using the package manager: sudo apt install libvtk9.1 libvtk9-dev. On macOS, one can use Homebrew to install it: brew install vtk. ViennaRay uses Embree as dependency which can be installed beforehand to save some time when building the dependencies. On Linux based systems, it can be installed using the package manager: sudo apt install libembree-dev. If you are using an Ubuntu version older than 24, the installed package will be Embree version 3, and you must additionally pass VIENNARAY_EMBREE_VERSION=3 to the CMake options, e.g., cmake -B build -G Ninja -D VIENNARAY_EMBREE_VERSION=3 On macOS, you can install Embree using Homebrew with the command: brew install embree. The CMake configuration automatically checks if the dependencies are installed. If CMake is unable to find them, the dependencies will be built from source with the buildDependencies target. Notably, ViennaPS operates as a header-only library, eliminating the need for a formal installation process. Nonetheless, we advise following the outlined procedure to neatly organize and relocate all header files to a designated directory: . git clone https://github.com/ViennaTools/ViennaPS.git cd ViennaPS cmake -B build -G Ninja &amp;&amp; cmake --build build cmake --install build --prefix \"/path/to/your/custom/install/\" . This will install the necessary headers and CMake files to the specified path. If --prefix is not specified, it will be installed to the standard path for your system, usually /usr/local/ . The -G Ninja option can be omitted if you prefer to use Unix Makefiles as the build system. However, this can potentially lead to conflicts when later installing the Python package using the pip installer, as pip always employs Ninja as the build system. ",
    "url": "/inst/#installing",
    
    "relUrl": "/inst/#installing"
  },"69": {
    "doc": "Installing the Library",
    "title": "Building the Python package locally",
    "content": "In order to build the Python bindings, the pybind11 library is required. On Linux based system (Ubuntu/Debian), pybind11 can be installed via the package manager: sudo apt install pybind11-dev. For macOS, the installation via Homebrew is recommended: brew install pybind11. The ViennaPS Python package can be built and installed using the pip command: . git clone https://github.com/ViennaTools/ViennaPS.git cd ViennaPS pip install . Some functionalities of the ViennaPS Python module only work in combination with the ViennaLS Python module. It is therefore necessary to additionally install the ViennaLS Python module on your system. Instructions to do so can be found in the ViennaLS Git Repository. ",
    "url": "/inst/#building-the-python-package-locally",
    
    "relUrl": "/inst/#building-the-python-package-locally"
  },"70": {
    "doc": "Installing the Library",
    "title": "Integration in CMake projects",
    "content": "We recommend using CPM.cmake to consume this library. | Installation with CPM CPMAddPackage(\"gh:viennatools/viennaps@3.1.0\") . | With a local installation In case you have ViennaPS installed in a custom directory, make sure to properly specify the CMAKE_PREFIX_PATH. list(APPEND CMAKE_PREFIX_PATH \"/your/local/installation\") find_package(ViennaPS) target_link_libraries(${PROJECT_NAME} PUBLIC ViennaTools::ViennaPS) . | . ",
    "url": "/inst/#integration-in-cmake-projects",
    
    "relUrl": "/inst/#integration-in-cmake-projects"
  },"71": {
    "doc": "Home",
    "title": "ViennaPS",
    "content": "Process Simulation Library . Get started now View it on GitHub . ViennaPS is a header-only C++ library for simulating microelectronic fabrication processes. It combines surface and volume representations with advanced level-set methods and Monte Carlo flux calculations, powered by high-performance ray tracing. Users can develop custom models, use pre-configured physical models, or leverage emulation for flexible and efficient process simulations. ViennaPS is designed to be easily integrated into existing C++ projects and provides Python bindings for seamless use in Python environments. The library is under active development and is continuously improved to meet the evolving needs of process simulation in microelectronics. ViennaPS is under heavy development and improved daily. If you do have suggestions or find bugs, please let us know on GitHub or contact us directly at viennatools@iue.tuwien.ac.at! . This documentation serves as your comprehensive guide to understanding, implementing, and harnessing the capabilities of our process simulation library. Whether you are a seasoned researcher seeking to refine your simulations or an engineer aiming to optimize real-world processes, this library provides a versatile and robust platform to meet your diverse needs. Throughout this documentation, you will find detailed explanations, practical examples, and best practices to effectively utilize the library. We aim to empower users with the knowledge and tools necessary to simulate a wide range of processes accurately and efficiently, making informed decisions and driving innovation in the field. ",
    "url": "/#viennaps",
    
    "relUrl": "/#viennaps"
  },"72": {
    "doc": "Home",
    "title": "Contributing",
    "content": "If you want to contribute to ViennaPS, make sure to follow the LLVM Coding guidelines. Make sure to format all files before creating a pull request: . cmake -B build cmake --build build --target format . ",
    "url": "/#contributing",
    
    "relUrl": "/#contributing"
  },"73": {
    "doc": "Home",
    "title": "About the project",
    "content": "ViennaPS was developed under the aegis of the Institute for Microelectronics at the TU Wien. Current contributors: Tobias Reiter, Noah Karnel, Roman Kostal, Lado Filipovic . Contact us via: viennatools@iue.tuwien.ac.at . ",
    "url": "/#about-the-project",
    
    "relUrl": "/#about-the-project"
  },"74": {
    "doc": "Home",
    "title": "License",
    "content": "See file LICENSE in the base directory. ",
    "url": "/#license",
    
    "relUrl": "/#license"
  },"75": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"76": {
    "doc": "Isotropic Process",
    "title": "Isotropic Process",
    "content": "#include &lt;psIsotropicProcess.hpp&gt; . An isotropic etching or deposition process initiates across all materials in the domain, excluding the masking material, which is by default set to Material::None. The default setting means, that the process unfolds uniformly across all materials within the domain. When the rate is less than 0, the material undergoes etching. Conversely, when the rate exceeds 0, material deposition occurs in accordance with the material of the top level set. If you want to deposit a new material, make sure to call the function duplicateTopLevelSet in your domain instance. psIsotropicProcess(const NumericType rate, const Material maskMaterial = Material::None) . | Parameter | Description | Type | . | rate | Rate of the process. | NumericType | . | maskMaterial | Material that does not participate in the process. | Material | . Deposition example: . C++ . #include &lt;psIsotropicProcess.hpp&gt; #include &lt;psMakeTrench.hpp&gt; #include &lt;psProcess.hpp&gt; using namespace viennaps; int main() { using NumericType = double; constexpr int D = 2; auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeTrench&lt;NumericType, D&gt;(domain, 0.1 /*gridDelta*/, 20. /*xExtent*/, 20. /*yExtent*/, 10. /*trenchWidth*/, 10. /*trenchDepth*/, 0., 0., false, false, Material::Si) .apply(); // duplicate top layer to capture deposition domain-&gt;duplicateTopLevelSet(Material::SiO2); auto model = SmartPointer&lt;IsotropicProcess&lt;NumericType, D&gt;&gt;::New( 0.1 /*rate*/, Material::None); domain-&gt;saveVolumeMesh(\"trench_initial\"); Process&lt;NumericType, D&gt;(domain, model, 20.).apply(); // run process for 20s domain-&gt;saveVolumeMesh(\"trench_final\"); } . Python . import viennaps2d as vps domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.1, xExtent=20.0, yExtent=20.0, trenchWidth=10.0, trenchDepth=10.0, taperingAngle=0.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si ).apply() # duplicate top layer to capture deposition domain.duplicateTopLevelSet(vps.Material.SiO2) model = vps.IsotropicProcess(rate=0.1) domain.saveVolumeMesh(\"trench_initial\") vps.Process(domain, model, 20.0).apply() domain.saveVolumeMesh(\"trench_final\") . Results: . Etching example: . C++ . #include &lt;psIsotropicProcess.hpp&gt; #include &lt;psMakeTrench.hpp&gt; #include &lt;psProcess.hpp&gt; using namespace viennaps; int main() { using NumericType = double; constexpr int D = 2; auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeTrench&lt;NumericType, D&gt;(domain, 0.1 /*gridDelta*/, 20. /*xExtent*/, 20. /*yExtent*/, 5. /*trenchWidth*/, 5. /*trenchDepth*/, 0., 0., false, true /*makeMask*/, Material::Si) .apply(); auto model = SmartPointer&lt;IsotropicProcess&lt;NumericType, D&gt;&gt;::New( -0.1 /*rate*/, Material::Mask); domain-&gt;saveVolumeMesh(\"trench_initial\"); Process&lt;NumericType, D&gt;(domain, model, 50.).apply(); // run process for 20s domain-&gt;saveVolumeMesh(\"trench_final\"); } . Python . import viennaps2d as vps domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.1, xExtent=20.0, yExtent=20.0, trenchWidth=5.0, trenchDepth=5.0, taperingAngle=0.0, baseHeight=0.0, periodicBoundary=False, makeMask=True, material=vps.Material.Si ).apply() model = vps.IsotropicProcess(rate=-0.1, maskMaterial=vps.Material.Mask) domain.saveVolumeMesh(\"trench_initial\", True) vps.Process(domain, model, 50.0).apply() domain.saveVolumeMesh(\"trench_final\", True) . ",
    "url": "/models/prebuilt/isotropic.html",
    
    "relUrl": "/models/prebuilt/isotropic.html"
  },"77": {
    "doc": "Level Set",
    "title": "Level Set",
    "content": ". ",
    "url": "/output/levelset.html",
    
    "relUrl": "/output/levelset.html"
  },"78": {
    "doc": "Level Set",
    "title": "Saving the Domain",
    "content": "Documentation Coming soon . ",
    "url": "/output/levelset.html#saving-the-domain",
    
    "relUrl": "/output/levelset.html#saving-the-domain"
  },"79": {
    "doc": "Level Set",
    "title": "Visualization",
    "content": "ViennaPS provides a feature enabling users to save the level set grid points explicitly for each material layer within the domain in the VTK file format. This export includes the level set value associated with each grid point. Users also have the option to specify a width parameter, determining the number of grid points around the zero level set. This functionality enhances the ability to analyze and visualize the level set information in a detailed and customizable manner. Example usage: . C++ . auto domain = ps::SmartPointer&lt;ps::Domain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveLevelSetMesh(\"fileNamePrefix\", 3 /* width */); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveLevelSetMesh(fileName=\"fileNamePrefix\", width=3) . ",
    "url": "/output/levelset.html#visualization",
    
    "relUrl": "/output/levelset.html#visualization"
  },"80": {
    "doc": "Logging",
    "title": "Logging",
    "content": ". Singleton class for thread-safe logging. The Logger class can be used to set the verbosity of the program. The verbosity levels are: . | Code | Description | . | ERROR | Log errors only | . | WARNING | Log warnings | . | INFO | Log information (e.g. remaining time) | . | TIMING | Log timing results for the different methods | . | INTERMEDIATE | Save intermediate results (disk meshes) during the process | . | DEBUG | Debug | . Example usage: Set the log level of the current program to INTERMEDIATE . C++ . ps::Logger::setLogLevel(ps::LogLevel::INTERMEDIATE); . Python . vps.Logger.setLogLevel(vps.LogLevel.INTERMEDIATE) . ",
    "url": "/misc/logging.html",
    
    "relUrl": "/misc/logging.html"
  },"81": {
    "doc": "Material Mapping",
    "title": "Material Mapping",
    "content": ". If specified, each Level-Set in the Domain class is assigned a specific material, which can be used in a process to implement material-specific rates or similar. The following materials are currently available in the Material enum: . | Material | Numeric Value | Description | . | None | -1 | Undefined Material | . | Mask | 0 | Mask Material | . | Si | 1 | Silicon | . | SiO2 | 2 | Silicon Dioxide | . | Si3N4 | 3 | Silicon Nitride | . | SiN | 4 | Silicon Nitride | . | SiON | 5 | Silicon Oxynitride | . | SiC | 6 | Silicon Carbide | . | SiGe | 7 | Silicon Germanium | . | PolySi | 8 | Polysilicon | . | GaN | 9 | Gallium Nitride | . | W | 10 | Tungsten | . | Al2O3 | 11 | Aluminum Oxide | . | HfO2 | 12 | Hafnium Oxide | . | TiN | 13 | Titanium Nitride | . | Cu | 14 | Copper | . | Polymer | 15 | Polymer | . | Dielectric | 16 | Dielectric Material | . | Metal | 17 | Metal | . | Air | 18 | Air | . | GAS | 19 | Gas | . Example: . C++ . auto material = Material::Si; . Python . material = vps.Material.Si; . ",
    "url": "/domain/material.html",
    
    "relUrl": "/domain/material.html"
  },"82": {
    "doc": "VTK Metadata Export",
    "title": "VTK Metadata Export",
    "content": ". ViennaPS supports exporting metadata to VTK output files. This feature allows users to embed additional simulation-specific and domain-specific information into the VTK files generated during surface, hull, or volume mesh output. The metadata is useful for post-processing, debugging, visualization, and reproducibility of simulation results. Metadata can be selectively included in VTK output by setting a metadata level, which controls the amount and type of information written. Metadata export is configured at the Domain level using the following static method: . Domain&lt;NumericType, D&gt;::enableMetaData(const MetaDataLevel level = MetaDataLevel::PROCESS); . Once enabled, metadata will be attached to all future VTK output from any domain instance during the current execution. ",
    "url": "/output/metadata.html",
    
    "relUrl": "/output/metadata.html"
  },"83": {
    "doc": "VTK Metadata Export",
    "title": "Metadata Levels",
    "content": "The MetaDataLevel enum defines the available levels of metadata: . | Level | Description | . | NONE | No metadata is written to VTK files. | . | GRID | Domain-specific metadata only (e.g., grid spacing, boundary conditions). | . | PROCESS | Includes domain metadata and parameters from the most recently applied process. | . | FULL | Includes all available metadata, such as advection model settings, ray tracing parameters, etc. | . The default level when enabling metadata is MetaDataLevel::PROCESS. ",
    "url": "/output/metadata.html#metadata-levels",
    
    "relUrl": "/output/metadata.html#metadata-levels"
  },"84": {
    "doc": "VTK Metadata Export",
    "title": "Usage Example",
    "content": "// Enable metadata export with full detail Domain&lt;double, 3&gt;::enableMetaData(MetaDataLevel::FULL); // Create domain and apply process auto domain = Domain&lt;double, 3&gt;::New(); ... Process&lt;double, 3&gt; process(domain, model); process.apply(); // Write output domain.saveSurfaceMesh(\"output_surface.vtp\"); // Surface mesh with metadata . The resulting VTK file will now contain metadata including grid spacing, boundary conditions, and all relevant parameters from the applied process. Python: . # Enable metadata export with full detail vps.Domain.enableMetaData(vps.MetaDataLevel.FULL) # Create domain and apply process domain = vps.Domain() ... process = vps.Process(domain, model) process.apply() # Write output domain.saveSurfaceMesh(\"output_surface.vtp\") # Surface mesh with metadata . ",
    "url": "/output/metadata.html#usage-example",
    
    "relUrl": "/output/metadata.html#usage-example"
  },"85": {
    "doc": "VTK Metadata Export",
    "title": "Process Metadata Behavior",
    "content": ". | Metadata at the PROCESS or FULL level always reflects the most recently applied process via .apply(). | When a new process is applied to a domain, the previously stored process metadata is cleared and replaced with the current one. | Only one set of process metadata is retained per domain at any time. | . ",
    "url": "/output/metadata.html#process-metadata-behavior",
    
    "relUrl": "/output/metadata.html#process-metadata-behavior"
  },"86": {
    "doc": "VTK Metadata Export",
    "title": "Affected Output Types",
    "content": "Metadata is supported in the following mesh outputs: . | Surface mesh (.vtp) | Hull mesh (.vtp) | Volume mesh (.vtu) | . Each writer automatically includes the metadata based on the current global setting. ",
    "url": "/output/metadata.html#affected-output-types",
    
    "relUrl": "/output/metadata.html#affected-output-types"
  },"87": {
    "doc": "VTK Metadata Export",
    "title": "Notes",
    "content": ". | The metadata system is static and global. Once enabled, it affects all domain instances during the simulation run. | For deterministic and reproducible output, it is recommended to enable metadata at the start of the simulation. | . ",
    "url": "/output/metadata.html#notes",
    
    "relUrl": "/output/metadata.html#notes"
  },"88": {
    "doc": "Multi Particle Process",
    "title": "Multi Particle Process",
    "content": "#include &lt;psMultiParticleProcess.hpp&gt; . The multi particle process is a simple process model that simulates either etching or deposition, where an arbitrary number of particles can be specified. The particles can be neutral or ions, and the model can be used to simulate a wide range of processes. The rate equation for combining the fluxes of the particles has to be provided by the user. ",
    "url": "/models/prebuilt/multiParticle.html#multi-particle-process",
    
    "relUrl": "/models/prebuilt/multiParticle.html#multi-particle-process"
  },"89": {
    "doc": "Multi Particle Process",
    "title": "Neutral Particles",
    "content": "Neutral particles are characterized by their sticking probability, which quantifies the likelihood that a neutral particle will adhere to a surface upon impact. This probability ranges between 0 and 1, where: . | A sticking probability of 1 indicates that the particle will always stick to the surface. | A sticking probability of 0 indicates that the particle will always be reflected. | . The sticking probability determines the reflection behavior of neutral particles and can be defined specifically for each material within the domain. ",
    "url": "/models/prebuilt/multiParticle.html#neutral-particles",
    
    "relUrl": "/models/prebuilt/multiParticle.html#neutral-particles"
  },"90": {
    "doc": "Multi Particle Process",
    "title": "Ion Particles",
    "content": "Ion particles are defined by their source exponent, which is the exponent of the power cosine distribution for the initial directions of the ions. The source exponent defines the distribution of the initial directions of the ions. A source exponent of 1 means that the ions are emitted isotropically, while a source exponent of 1000 means that the ions are emitted mostly perpendicular to the surface. The ion sticking function is defined by the parameters $\\theta_{min}$ and $\\theta_{max}$. The ion sticking function is a function of the incoming angle $\\theta$ that defines the probability that an ion will stick to the surface upon impact. The ion sticking function is a linear function defined as: . \\[S(\\theta) = \\begin{cases} 0 &amp; \\text{if } \\theta &lt; \\theta_{min} \\\\ 1 &amp; \\text{if } \\theta &gt; \\theta_{max} \\\\ \\frac{\\theta - \\theta_{min}}{\\theta_{max} - \\theta_{min}} &amp; \\text{otherwise} \\end{cases}\\] Ions striking the surface at an angle denoted by $\\theta$ relative to the surface normal undergo reflection, where the angular dispersion is characterized by a cosine function centered around the direction of specular reflection defined by $\\theta_\\textrm{spec}$. This reflection process distinguishes between ions approaching the surface at glancing angles, which undergo nearly perfect specular reflection, and those striking the surface perpendicularly, which undergo nearly diffuse reflection. The ray’s reflected direction is randomly chosen from a cone around the specular direction. The opening angle of this cone is given by the incidence angle $\\theta$ or the minimum specified angle $\\theta_{min}$. Optional Parameters: . Ion can be assigned an energy which can be used to calculate a surface yield. This feature can be activated by setting the mean energy &gt; 0 and is deactivated by setting the mean energy = 0. The energy distribution of the ions is assumed to be Gaussian with a standard deviation of sigmaEnergy. The threshold energy is the energy below which the ion will not sputter the surface, and the energy dependent yield is defined as: . \\[Y(E) = \\begin{cases} 0 &amp; \\text{if } E &lt; E_{\\textrm{threshold}} \\\\ \\sqrt{E} - \\sqrt{E_{\\textrm{threshold}}} &amp; \\text{if } E \\geq E_{\\textrm{threshold}} \\end{cases}\\] The inflection angle and n are parameters of the ion energy reduction function, which is used to calculate the energy after reflection. The ion energy reduction function is defined as: . \\[E_{\\textrm{ref}}= \\begin{cases} 1-(1-A)\\frac{\\frac{\\pi}{2}-\\theta}{\\frac{\\pi}{2}-\\theta_\\textrm{inflect}} &amp; \\text{ if } \\theta \\geqslant \\theta_\\textrm{inflect} \\\\ \\mathrm{A}\\left(\\frac{\\theta}{\\theta_\\textrm{inflect}}\\right)^{n_l} &amp; \\text{ if } \\theta&lt;\\theta_\\textrm{inflect}, \\end{cases}\\] where $A = (1 + n(\\frac{\\pi}{2 \\theta_\\textrm{inflect}} - 1))^{-1}$. The angle-dependent sputtering yield is defined as: . \\begin{equation} Y(\\theta) = (1 + B_{sp}(1-\\cos^2(\\theta)))\\cos(\\theta). \\end{equation} . ",
    "url": "/models/prebuilt/multiParticle.html#ion-particles",
    
    "relUrl": "/models/prebuilt/multiParticle.html#ion-particles"
  },"91": {
    "doc": "Multi Particle Process",
    "title": "Implementation",
    "content": "// default empty constructor MultiParticleProcess() // member functions void addNeutralParticle(NumericType stickingProbability, std::string label = \"neutralFlux\") void addNeutralParticle(std::unordered_map&lt;Material, NumericType&gt; materialSticking, NumericType defaultStickingProbability = 1., std::string label = \"neutralFlux\") void addIonParticle(NumericType sourceExponent, NumericType thetaRMin = 0., NumericType thetaRMax = 90., NumericType minAngle = 0., NumericType B_sp = -1., NumericType meanEnergy = 0., NumericType sigmaEnergy = 0., NumericType thresholdEnergy = 0., NumericType inflectAngle = 0., NumericType n = 1, std::string label = \"ionFlux\") void setRateFunction(std::function&lt;NumericType(std::vector&lt;NumericType&gt; &amp;, const Material &amp;)&gt; rateFunction) . | Parameter | Description | Default Value | . | stickingProbability | Sticking probability of the neutral particle | - | . | sourceExponent | Exponent of the power cosine distribution for the initial directions of ions | - | . | thetaRMin | $\\theta_{min}$ in the ion sticking function | 0.0 | . | thetaRMax | $\\theta_{max}$ in the ion sticking function | 90.0 | . | minAngle | Minimum angle for the ion reflection | 0.0 | . | B_sp | Sputtering yield parameter | -1.0 | . | meanEnergy | Mean initial energy of the ions | 0.0 | . | sigmaEnergy | Standard deviation of the initial energy of the ions | 0.0 | . | thresholdEnergy | Threshold energy for ion sputtering | 0.0 | . | inflectAngle | Inflection angle of the ion energy reduction function | 0.0 | . | n | Exponent of the ion energy reduction function | 1.0 | . The sticking probability of the neutral particle can also be specified for each material within the domain using a map between material and sticking probability. Example usage: . C++ ... auto model = SmartPointer&lt;MultiParticleProcess&lt;NumericType, D&gt;&gt;::New(); std::unordered_map&lt;Material, NumericType&gt; materialSticking{{Material::Si, 0.1}, {Material::Mask, 0.5}}; model-&gt;addNeutralParticle(materialSticking, 1.0); // default sticking probability of 1 on all other materials model-&gt;addIonParticle(1000.); // for material specific rates auto rateFunction = [](std::vector&lt;NumericType&gt; &amp;fluxes, const Material &amp;material) { // fluxes contains the neutral flux at first index and ion flux at second index return material == Material::Si ? -(fluxes[0] + fluxes[1]) : 0.; }; model-&gt;setRateFunction(rateFunction); ... Python ... model = vps.MultiParticleProcess() materialSticking = {vps.Material.Si: 0.1, vps.Material.Mask: 0.5} model.addNeutralParticle(materialSticking, defaultStickingProbability=1.0) model.addIonParticle(1000.) # for material specific rates def rateFunction(fluxes, material): if material == vps.Material.Si: # fluxes contains the neutral flux at first index and ion flux at second index return -sum(fluxes) else: return 0. model.setRateFunction(rateFunction) ... ",
    "url": "/models/prebuilt/multiParticle.html#implementation",
    
    "relUrl": "/models/prebuilt/multiParticle.html#implementation"
  },"92": {
    "doc": "Multi Particle Process",
    "title": "Related Examples",
    "content": ". | Bosch Process | . ",
    "url": "/models/prebuilt/multiParticle.html#related-examples",
    
    "relUrl": "/models/prebuilt/multiParticle.html#related-examples"
  },"93": {
    "doc": "Multi Particle Process",
    "title": "Multi Particle Process",
    "content": " ",
    "url": "/models/prebuilt/multiParticle.html",
    
    "relUrl": "/models/prebuilt/multiParticle.html"
  },"94": {
    "doc": "Oxide Regrowth",
    "title": "Oxide Regrowth",
    "content": "#include &lt;psOxideRegrowth.hpp&gt; . Modelling of oxide regrowth in during selective etching in stack of alternation SiO2 and Si3N4 layers. Based on the model presented here1. ",
    "url": "/models/prebuilt/oxideRegrowth.html#oxide-regrowth",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html#oxide-regrowth"
  },"95": {
    "doc": "Oxide Regrowth",
    "title": "Related Examples",
    "content": ". | Oxide Regrowth | . | Tobias Reiter, Alexander Toifl, Andreas Hössinger, Lado Filipovic; Modeling Oxide Regrowth During Selective Etching in Vertical 3D NAND Structures. in: 2023 International Conference on Simulation of Semiconductor Processes and Devices (SISPAD) 2023, pp 85–88. https://doi.org/10.23919/SISPAD57422.2023.10319506 &#8617; . | . ",
    "url": "/models/prebuilt/oxideRegrowth.html#related-examples",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html#related-examples"
  },"96": {
    "doc": "Oxide Regrowth",
    "title": "Oxide Regrowth",
    "content": " ",
    "url": "/models/prebuilt/oxideRegrowth.html",
    
    "relUrl": "/models/prebuilt/oxideRegrowth.html"
  },"97": {
    "doc": "Parsing Parameters",
    "title": "Parsing Parameters",
    "content": ". Coming soon . ",
    "url": "/misc/parsing.html",
    
    "relUrl": "/misc/parsing.html"
  },"98": {
    "doc": "Particles - Flux Calculation",
    "title": "Particles - Flux Calculation",
    "content": ". ViennaPS integrates advanced ray tracing techniques, leveraging the power of the ViennaRay library based on Intel®’s Embree ray tracing kernel, into the realm of process simulations. This combination enables precise and efficient flux calculations within topography simulations. This process includes launching rays from a source and tracing their paths as they interact with the surface geometry. Ray tracing allows for the simulation of complex phenomena such as shadows, reflections, and transmission of energy through transparent materials. ViennaPS integrates ViennaRay functionality through the viennaray::Particle class, providing users with a versatile interface to define the key characteristics of the simulated particle species and tailor their behavior upon surface interactions, including reflective properties. Within the particle class, users can fine-tune parameters governing the initial state of particles, enabling precise control over their interactions with material surfaces. For an in-depth understanding of the viennaray::Particle class and its functionalities, users are encouraged to refer to the detailed documentation available within the ViennaRay documentation. Within ViennaPS, a process model has the flexibility to encompass multiple particle species, each contributing distinct characteristics to the simulation. The fluxes computed from these particles are conveniently accessible through the SurfaceModel class. This interface allows users to seamlessly integrate the particle flux data into a physical model, facilitating the simulation of intricate physical processes. By leveraging the calculated fluxes within the surface model, users can construct comprehensive simulations that capture the nuanced interplay of particles and materials, offering a robust framework for exploring diverse scenarios in process simulation. ",
    "url": "/models/custom/particle.html",
    
    "relUrl": "/models/custom/particle.html"
  },"99": {
    "doc": "Planarize Geometry",
    "title": "Planarize a Geometry",
    "content": "#include &lt;psPlanarize.hpp&gt; . With this class, the user is able to planarize the domain at a specified cutoff position. The planarization process involves subtracting a plane from all materials within the domain using a boolean operation. Example usage: . C++ . ps::Planarize&lt;double, 3&gt;(domain, 0. /*cut off height in z-direction*/).apply(); . Python . vps.Planarize(geometry=domain, cutoffHeight=0.).apply() . ",
    "url": "/misc/planarize.html#planarize-a-geometry",
    
    "relUrl": "/misc/planarize.html#planarize-a-geometry"
  },"100": {
    "doc": "Planarize Geometry",
    "title": "Planarize Geometry",
    "content": " ",
    "url": "/misc/planarize.html",
    
    "relUrl": "/misc/planarize.html"
  },"101": {
    "doc": "Plane Geometry",
    "title": "Plane Geometry",
    "content": "#include &lt;geometries/psMakePlane.hpp&gt; . The MakePlane class offers a straightforward approach to generate a plane as a level-set within your domain. This utility is useful for crafting substrates with any material. You have the flexibility to append the plane to an existing geometry or create a new one. In 3D, the plane is generated with a normal direction in the positive z direction, while in 2D, it is oriented in the positive y direction. The plane is centered around the origin, with the total specified extent and height. Additionally, you can opt for a periodic boundary in the x and y directions. // namespace viennaps MakePlane(psDomainType domain, NumericType baseHeight = 0., Material material = Material::Si, bool addToExisting = false) MakePlane(psDomainType domain, NumericType gridDelta, NumericType xExtent, NumericType yExtent, NumericType baseHeight, bool periodicBoundary = false, Material material = Material::Si) . Depending on the specific constructor invoked for the plane-builder, the behavior varies: the domain may be cleared, and a new plane inserted, or the plane can be added to the existing geometry in the domain. A detailed description of the parameters follows: . | Parameter | Type | Description | Applicable Constructor | . | domain | psDomainType | The simulation domain. | Both | . | baseHeight | NumericType | Height at which the plane is placed (default: 0.). | Both | . | material | Material | Material of the plane (default: Material::Si). | Both | . | addToExisting | bool | If true, the plane is added to an existing geometry instead of creating a new one (default: false). | First constructor only | . | gridDelta | NumericType | Grid spacing in the simulation domain. | Second constructor only | . | xExtent | NumericType | Extent of the domain in the x-direction. | Second constructor only | . | yExtent | NumericType | Extent of the domain in the y-direction. | Second constructor only | . | periodicBoundary | bool | If true, enables periodic boundary conditions (default: false). | Second constructor only | . Note: . | The first constructor requires that the domain is already configured and allows adding a plane to an existing geometry. | The second constructor creates a new geometry and sets up the domain using gridDelta, xExtent, and yExtent. | . Example usage: . | Creating a new domain: | . C++ . // namespace viennaps auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(0.5, 10., 10., BoundaryType::REFLECTIVE_BOUNDARY); MakePlane&lt;NumericType, D&gt;(domain, 0.0, Material::Si).apply(); . Python . domain = vps.Domain(gridDelta=0.5, xExtent=10.0, yExtent=10.0, boundaryType=vps.BoundaryType.REFLECTIVE_BOUNDARY) vps.MakePlane(domain=domain, baseHeight=0.0, material=vps.Material.Si, ).apply() . | Adding plane to existing domain | . C++ . MakePlane&lt;NumericType, D&gt;(domain, 10.0, Material::Si, true).apply(); . Python . vps.MakePlane(domain=domain, height=0.0, material=vps.Material.Si, addToExisting=True ).apply() . ",
    "url": "/geo/basic/plane.html",
    
    "relUrl": "/geo/basic/plane.html"
  },"102": {
    "doc": "Point Data",
    "title": "Point Data",
    "content": ". The viennals::PointData class is designed to hold data associated with points in space. It’s a generic class that can work with any data type T that satisfies the lsConcepts::IsFloatingPoint concept. By default, it uses double as the data type. Member Types: . | ScalarDataType: A type alias for a vector of T type elements. This is used to represent scalar data. | VectorDataType: A type alias for a vector of arrays, each containing 3 elements of T type. This is used to represent vector data. | . Public Methods: . | insertNextScalarData: This method inserts a new scalar data its corresponding label. | . ",
    "url": "/misc/pointData.html",
    
    "relUrl": "/misc/pointData.html"
  },"103": {
    "doc": "Domain Setup",
    "title": "Domain Setup",
    "content": ". The DomainSetup class defines the geometric grid configuration for a simulation domain in ViennaPS. It stores bounds, boundary conditions, and grid resolution (gridDelta) and is used internally by the Domain class to initialize the underlying hrleGrid. ",
    "url": "/domain/setup.html",
    
    "relUrl": "/domain/setup.html"
  },"104": {
    "doc": "Domain Setup",
    "title": "Features",
    "content": ". | Manage domain extents and resolution | Configure boundary conditions | Create and store an hrle::Grid based on bounds and resolution | Validate and print domain setup parameters | Support halving geometries for symmetry exploitation | . ",
    "url": "/domain/setup.html#features",
    
    "relUrl": "/domain/setup.html#features"
  },"105": {
    "doc": "Domain Setup",
    "title": "Constructors",
    "content": "DomainSetup(); DomainSetup(double bounds[2 * D], BoundaryType boundaryCons[D], NumericType gridDelta); DomainSetup(NumericType gridDelta, NumericType xExtent, NumericType yExtent, BoundaryType boundary); . | Default constructor initializes all bounds to zero with INFINITE_BOUNDARY. | Bounding box constructor accepts explicit bounds and boundary conditions. | Extent constructor simplifies setup by defining half-extents along the x and y axes and applies default or specified boundary types. | . ",
    "url": "/domain/setup.html#constructors",
    
    "relUrl": "/domain/setup.html#constructors"
  },"106": {
    "doc": "Domain Setup",
    "title": "Member Functions",
    "content": "Accessors . auto&amp; grid() const; NumericType gridDelta() const; std::array&lt;double, 2 * D&gt; bounds() const; std::array&lt;BoundaryType, D&gt; boundaryCons() const; NumericType xExtent() const; NumericType yExtent() const; . Access the internal grid, resolution, and geometric/boundary parameters. Geometry Modification . void halveXAxis(); void halveYAxis(); . Modify the domain to simulate only half the geometry (along x or y), useful for symmetry. These operations are not allowed if periodic boundaries are used. Initialization . void init(); void init(viennahrle::Grid&lt;D&gt; grid); . Construct or update the internal HRLE grid from the configured bounds, resolution, and boundary types. Debugging . void print() const; . Prints all configured parameters to stdout, including grid delta, extents, and boundary configuration. ",
    "url": "/domain/setup.html#member-functions",
    
    "relUrl": "/domain/setup.html#member-functions"
  },"107": {
    "doc": "Domain Setup",
    "title": "Example",
    "content": "using Setup = viennaps::DomainSetup&lt;double, 3&gt;; BoundaryType boundaries[3] = { BoundaryType::REFLECTIVE_BOUNDARY, BoundaryType::REFLECTIVE_BOUNDARY, BoundaryType::INFINITE_BOUNDARY }; double bounds[6] = {-5.0, 5.0, -5.0, 5.0, -1.0, 1.0}; Setup setup(bounds, boundaries, 0.5); setup.print(); . ",
    "url": "/domain/setup.html#example",
    
    "relUrl": "/domain/setup.html#example"
  },"108": {
    "doc": "Domain Setup",
    "title": "Notes",
    "content": ". | In 2D, the yExtent() function still exists but returns the fixed height of the domain. | Grid cells are computed as integer multiples of gridDelta, ensuring alignment with HRLE. | The final z-direction always has an INFINITE_BOUNDARY to prevent undesired reflection artifacts during etching or deposition. | . ",
    "url": "/domain/setup.html#notes",
    
    "relUrl": "/domain/setup.html#notes"
  },"109": {
    "doc": "Single Particle Process",
    "title": "Single Particle Process",
    "content": "#include &lt;psSingleParticleProcess.hpp&gt; . The single particle process is a simple process model that simulates either etching or deposition, assuming a single particle species. The process is specified by the rate, the particle sticking coefficient, and the exponent in the power cosine distribution of the initial particle directions. The rate can be either negative or positive, corresponding to etching or deposition, respectively. The sticking coefficient is the probability that a particle will stick to the surface upon impact, thus controlling the number of diffusive reflections from the surface. The exponent in the power cosine distribution of the initial particle directions is a measure of the angular spread of the initial particle directions. A higher exponent corresponds to a more focused beam of particles. Additionally, mask materials can be specified, where the rate is assumed to be zero, or map between material and rate can be defined. ",
    "url": "/models/prebuilt/singleParticle.html",
    
    "relUrl": "/models/prebuilt/singleParticle.html"
  },"110": {
    "doc": "Single Particle Process",
    "title": "Implementation",
    "content": "SingleParticleProcess(const NumericType rate = 1., const NumericType stickingProbability = 1., const NumericType sourceDistributionPower = 1., const Material maskMaterial = Material::None) SingleParticleProcess(const NumericType rate, const NumericType stickingProbability, const NumericType sourceDistributionPower, const std::vector&lt;Material&gt; maskMaterials) SingleParticleProcess(std::unordered_map&lt;Material, NumericType&gt; materialRates, NumericType stickingProbability, NumericType sourceDistributionPower) . | Parameter | Description | Default Value | . | rate | Default rate of the single particle process, if no material specific rates are defined | 1.0 | . | stickingProbability | Sticking probability of particles | 1.0 | . | sourceDistributionPower | Power of the power cosine source distribution | 1.0 | . | maskMaterial | Mask material | Material::None | . Rates can also be specified for specific materials using a map between material and rate. Example usage: . C++ ... // for a single mask material auto model = SmartPointer&lt;SingleParticleProcess&lt;NumericType, D&gt;&gt;::New(1., 0.1, 1., maskMaterial); ... // for multiple mask materials auto model = SmartPointer&lt;SingleParticleProcess&lt;NumericType, D&gt;&gt;::New(1., 0.1, 1., {mask1, mask2}); // for material specific rates std::unordered_map&lt;Material, NumericType&gt; materialRates = {{Material::Si, 1.}, {Material::SiO2, 0.5}}; auto model = SmartPointer&lt;SingleParticleProcess&lt;NumericType, D&gt;&gt;::New(materialRates, 0.1, 1.); ... Python ... model = vps.SingleParticleProcess(rate=1., stickingProbability=0.1, sourceExponent=1., maskMaterials=[maskMaterial]) # using material specific rates rates = {vps.Material.Si: 1., vps.Material.SiO2: 0.5} model = vps.SingleParticleProcess(materialRates=rates, stickingProbability=0.1, sourceExponent=1.) ... ",
    "url": "/models/prebuilt/singleParticle.html#implementation",
    
    "relUrl": "/models/prebuilt/singleParticle.html#implementation"
  },"111": {
    "doc": "Single Particle Process",
    "title": "Related Examples",
    "content": ". | Trench Deposition | . ",
    "url": "/models/prebuilt/singleParticle.html#related-examples",
    
    "relUrl": "/models/prebuilt/singleParticle.html#related-examples"
  },"112": {
    "doc": "Primary Source Direction",
    "title": "Primary Source Direction",
    "content": ". The primary source direction is an optional parameter that allows users to tailor the initial particle direction distribution by specifying a tilt during flux calculation from a source plane. In cases where no primary source direction is explicitly defined, it defaults to being aligned with the surface normal of the source plane. If there is no intention to tilt the initial distribution, it is advisable not to set the primary source direction equal to the source plane normal. Instead, using the default value is recommended for a slight performance advantage. Example usage: . auto myModel = ps::SmartPointer&lt;ps::ProcessModel&lt;NumericType, D&gt;&gt;::New(); double tiltingAngle = 30. * M_PI / 180.; // tilting angle of 30 degree double x = -std::sin(tiltingAngle); double y = -std::cos(tiltingAngle); myModel-&gt;setPrimaryDirection({x, y, -1.}); . ",
    "url": "/models/custom/sourceDirection.html",
    
    "relUrl": "/models/custom/sourceDirection.html"
  },"113": {
    "doc": "Stack Geometry",
    "title": "Stack Geometry",
    "content": "#include &lt;geometries/psMakeStack.hpp&gt; . The MakeStack generates a stack of alternating SiO2/Si3N4 layers featuring an optionally etched hole (3D) or trench (2D) at the center. The stack emerges in the positive z direction (3D) or y direction (2D) and is centered around the origin, with its x/y extent specified. Users have the flexibility to introduce periodic boundaries in the x and y directions. Additionally, the stack can incorporate a top mask with a central hole of a specified radius or a trench with a designated width. This versatile functionality enables users to create diverse and customized structures for simulation scenarios. // namespace viennaps // with DomainSetup configured (v3.3.0) MakeStack(psDomainType domain, int numLayers, NumericType layerHeight, NumericType substrateHeight, NumericType holeRadius, NumericType trenchWidth, NumericType maskHeight, NumericType taperAngle, bool halfStack = false, Material maskMaterial = Material::Mask) MakeStack(DomainType domain, NumericType gridDelta, NumericType xExtent, NumericType yExtent, int numLayers, NumericType layerHeight, NumericType substrateHeight, NumericType holeRadius, NumericType trenchWidth, NumericType maskHeight, bool periodicBoundary = false) . | Parameter | Description | Type | . | domain | Specifies the domain type for the stack geometry. | SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the stack geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the stack geometry in the y-direction. | NumericType | . | numLayers | Sets the number of layers in the stack. | int | . | layerHeight | Determines the height of each layer in the stack. | NumericType | . | substrateHeight | Specifies the height of the substrate. | NumericType | . | holeRadius | Sets the radius of the hole. | NumericType | . | trenchWidth | Determines the width of the trench. | NumericType | . | maskHeight | Specifies the height of the mask. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries. Default is set to false. | bool | . trenchWidth and holeRadius can only be used mutually exclusive. I.e., if one is set, the other has to be set to 0. Example usage: . C++ . // namespace viennaps auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeStack&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5, 5.0, 10., 0.0, 5.0, 0.0, false) .apply(); . Python . domain = vps.Domain() vps.MakeStack(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, numLayers=5, layerHeight=5.0, substrateHeight=10.0, holeRadius=0.0, trenchWidth=5.0, maskHeight=0.0, periodicBoundary=False, ).apply() . ",
    "url": "/geo/basic/stack.html",
    
    "relUrl": "/geo/basic/stack.html"
  },"114": {
    "doc": "Surface Mesh",
    "title": "Surface Mesh",
    "content": ". To save a triangulated mesh of the geometry surface, users can use the domain member function saveSurfaceMesh. The surface mesh also contains material information is the optional parameter addMaterialIds is set to true. Example usage: . C++ . auto domain = ps::SmartPointer&lt;ps::Domain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveSurfaceMesh(\"fileName\", true); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveSurfaceMesh(fileName=\"fileName\", addMaterialIds=True) . ",
    "url": "/output/surface.html",
    
    "relUrl": "/output/surface.html"
  },"115": {
    "doc": "Surface and Material Interfaces",
    "title": "Surface and Material Interfaces",
    "content": ". The surface, as well as the material interfaces, are described implicitly by a level set (LS) function $\\phi(\\vec{x})$ which is defined at every point $\\vec{x}$ in space. This function is obtained using signed distance transforms, describing the surface $S$ as the zero LS: . \\[S = \\{\\vec{x}\\!: \\, \\phi(\\vec{x}) = 0 \\}.\\] If the domain contains multiple LSs, the top LS wraps the entire structure and therefore represents the surface, while all other LS functions just describe material interfaces. Formally, the different material regions can be described by ${M}$ LS functions satisfying . \\[\\Phi_k(\\vec{x}) \\leq 0 \\quad \\Leftrightarrow \\quad \\vec{x} \\in \\bigcup_{i=1}^k \\mathcal{M}_i.\\] Here $\\Phi_M$ describes the entire structure $\\mathcal{M}$, and the other LS functions correspond to material interfaces. When inserting a new LS into the domain, an automatic wrapping process ensues. This process involves enveloping all existing Level-Sets through a Boolean operation, specifically a union with the topmost LS. It’s worth noting, though, that this default behavior is not obligatory. In instances where a specialized domain structure is desired, users have the option to circumvent this automatic wrapping mechanism. ",
    "url": "/domain/surface.html#surface-and-material-interfaces",
    
    "relUrl": "/domain/surface.html#surface-and-material-interfaces"
  },"116": {
    "doc": "Surface and Material Interfaces",
    "title": "Surface and Material Interfaces",
    "content": " ",
    "url": "/domain/surface.html",
    
    "relUrl": "/domain/surface.html"
  },"117": {
    "doc": "Surface Model",
    "title": "Surface Model",
    "content": ". ",
    "url": "/models/custom/surfaceModel.html",
    
    "relUrl": "/models/custom/surfaceModel.html"
  },"118": {
    "doc": "Surface Model",
    "title": "Summary",
    "content": ". | The SurfaceModel class is used to describe surface reactions, combining particle fluxes with the surface chemical reactions. | The velocities used for surface advection in a time step are calculated through the calculateVelocities() function. | Surface coverages can be used to track the coverage a chemical species on the surface through a time step. | The coverages can be initialized to equilibrium by iteratively calculating the fluxes on the surface and updating the coverages. The number of iterations to initialize the coverages can be specified through the Process. | Coverages and fluxes are stored as viennals::PointData. | . The SurfaceModel class serves as a comprehensive framework for detailing surface chemistries. Users have the flexibility to create a customized child class where they can precisely dictate how surface coverages evolve, driven by the rates at which particles impact the surface. One key feature is the capability to monitor surface coverages, providing insights into the presence of chemical species on the surface throughout a simulation’s time step. To initialize the coverage data vector, the method initializeCoverages() is employed. void initializeCoverages(unsigned numSurfacePoints) override { // a single set of coverages is initialized here std::vector&lt;NumericType&gt; someCoverage(numSurfacePoints, 0); coverages = ps::SmartPointer&lt;viennals::PointData&lt;NumericType&gt;&gt;::New(); coverages-&gt;insertNextScalarData(someCoverage, \"someCoverage\"); } . To use coverages, it is essential to initialize the class member coverages with a new instance of viennals::PointData. If the coverages variable is left as nullptr, no coverages will be utilized during the simulation. To initialize a single coverage, a container with a size equal to the number of surface points must be created and inserted into the viennals::PointData. Additionally, a name for the coverage can be specified during initialization. This designated name should then be used in updateCoverages() or calculateVelocities() to access the specific coverage as needed. To ensure accurate representations, coverages can be initialized to equilibrium by iteratively calculating surface fluxes and updating coverages. The initialization process’s iteration count is customizable through the Process interface. The method updateCoverages() encapsulates the user-defined description of surface coverage evolution in each iteration. Since coverages is a member of the psSurfaceModel class, it can be accessed in every member function. void updateCoverages(ps::SmartPointer&lt;viennals::PointData&lt;NumericType&gt;&gt; particleFluxes, const std::vector&lt;NumericType&gt; &amp;materialIds) override { auto myCoverage = coverages-&gt;getScalarData(\"someCoverage\"); // update coverage from calculated fluxes } . Within the psSurfaceModel class, the method calculateVelocities() utilizes fluxes obtained through ray tracing, to provide the velocities used for surface advection in a time step. Here the fluxes from particle, as well as previously calculated coverages can be accessed and combined to yield the final velocity at each surface point. The function should return a SmartPointer to a new vector, containing the velocity at each surface point. In order to create a custom surface the user has to interface the SurfaceModel class. An example implementation of a custom surface model is given below: . template &lt;typename NumericType&gt; class myCustomSurfaceModel : public ps::SurfaceModel&lt;NumericType&gt; { public: using ps::SurfaceModel&lt;NumericType&gt;::coverages; // needed to access coverages void initializeCoverages(unsigned numSurfacePoints) override { // a single set of coverages is initialized here std::vector&lt;NumericType&gt; someCoverage(numSurfacePoints, 0); coverages = ps::SmartPointer&lt;viennals::PointData&lt;NumericType&gt;&gt;::New(); coverages-&gt;insertNextScalarData(someCoverage, \"someCoverage\"); } void updateCoverages(ps::SmartPointer&lt;viennals::PointData&lt;NumericType&gt;&gt; particleFluxes, const std::vector&lt;NumericType&gt; &amp;materialIds) override { auto myCoverage = coverages-&gt;getScalarData(\"someCoverage\"); // update coverage from calculated fluxes } ps::SmartPointer&lt;std::vector&lt;NumericType&gt;&gt; calculateVelocities( ps::SmartPointer&lt;viennals::PointData&lt;NumericType&gt;&gt; rates, const std::vector&lt;std::array&lt;NumericType, 3&gt;&gt; &amp;coordinates, const std::vector&lt;NumericType&gt; &amp;materialIds) override { // use coverages and rates here to calculate the velocity here return ps::SmartPointer&lt;std::vector&lt;NumericType&gt;&gt;::New( *rates-&gt;getScalarData(\"particleRate\")); } }; . ",
    "url": "/models/custom/surfaceModel.html#summary",
    
    "relUrl": "/models/custom/surfaceModel.html#summary"
  },"119": {
    "doc": "Trench Geometry",
    "title": "Trench Geometry",
    "content": "#include &lt;geometries/psMakeTrench.hpp&gt; . The MakeTrench class is used to generate a new trench geometry extending in the z (3D) or y (2D) direction, centrally positioned at the origin with the total extent specified in the x and y directions. The trench configuration may include periodic boundaries in both the x and y directions. Users have the flexibility to define the trench’s width, depth, and incorporate tapering with a designated angle. Moreover, the trench can serve as a mask, applying the specified material exclusively to the bottom while the remaining portion adopts the mask material. // namespace viennaps // with DomainSetup configured (v3.3.0) MakeTrench(psDomainType domain, NumericType trenchWidth, NumericType trenchDepth, NumericType trenchTaperAngle = 0, NumericType maskHeight = 0, NumericType maskTaperAngle = 0, bool halfTrench = false, Material material = Material::Si, Material maskMaterial = Material::Mask) MakeTrench(DomainType domain, NumericType gridDelta, NumericType xExtent, NumericType yExtent, NumericType trenchWidth, NumericType trenchDepth, NumericType taperingAngle = 0., // in degrees NumericType baseHeight = 0., bool periodicBoundary = false, bool makeMask = false, Material material = Material::Si) . | Parameter | Description | Type | . | domain | Specifies the type of domain for the trench geometry. | SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt; | . | gridDelta | Represents the grid spacing or resolution used in the simulation. | NumericType | . | xExtent | Defines the extent of the trench geometry in the x-direction. | NumericType | . | yExtent | Specifies the extent of the trench geometry in the y-direction. | NumericType | . | trenchWidth | Sets the width of the trench. | NumericType | . | trenchDepth | Determines the depth of the trench. | NumericType | . | taperingAngle | (Optional) Specifies the angle of tapering for the trench geometry in degrees. Default is set to 0. | NumericType | . | baseHeight | (Optional) Sets the base height of the trench. Default is set to 0. | NumericType | . | periodicBoundary | (Optional) If set to true, enables periodic boundaries in both x and y directions (only applicable in 3D). Default is set to false. | bool | . | makeMask | (Optional) If set to true, allows the trench to function as a mask, with specified material applied only to the bottom. Default is set to false. | bool | . | material | (Optional) Specifies the material used for the trench. Default is set to Material_None. | Material | . Example usage: . C++ . // namespace viennaps auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New(); MakeTrench&lt;NumericType, D&gt;(domain, 0.5, 10.0, 10.0, 5.0, 5.0, 10., 0., false, false, Material::Si) .apply(); . Python . domain = vps.Domain() vps.MakeTrench(domain=domain, gridDelta=0.5, xExtent=10.0, yExtent=10.0, trenchWidth=5.0, trenchDepth=5.0, taperingAngle=10.0, baseHeight=0.0, periodicBoundary=False, makeMask=False, material=vps.Material.Si, ).apply() . ",
    "url": "/geo/basic/trench.html",
    
    "relUrl": "/geo/basic/trench.html"
  },"120": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": ". ",
    "url": "/inst/troubleshooting.html",
    
    "relUrl": "/inst/troubleshooting.html"
  },"121": {
    "doc": "Troubleshooting",
    "title": "Failed Python package build",
    "content": "The following error can occur while building the Python package using pip: . Building wheels for collected packages: ViennaPS_Python Building wheel for ViennaPS_Python (pyproject.toml) ... error error: subprocess-exited-with-error × Building wheel for ViennaPS_Python (pyproject.toml) did not run successfully. │ exit code: 1 ╰─&gt; [21 lines of output] *** scikit-build-core 0.9.3 using CMake 3.27.4 (wheel) *** Configuring CMake... loading initial cache file build/CMakeInit.txt -- CPM: Adding package PackageProject@1.11.1 (v1.11.1) ninja: error: Makefile:5: expected '=', got ':' default_target: all ^ near here CMake Error at /usr/share/cmake-3.27/Modules/FetchContent.cmake:1662 (message): Build step for packageproject failed: 1 Call Stack (most recent call first): /usr/share/cmake-3.27/Modules/FetchContent.cmake:1802:EVAL:2 (__FetchContent_directPopulate) /usr/share/cmake-3.27/Modules/FetchContent.cmake:1802 (cmake_language) build/cmake/CPM_0.38.6.cmake:1004 (FetchContent_Populate) build/cmake/CPM_0.38.6.cmake:798 (cpm_fetch_package) CMakeLists.txt:98 (CPMAddPackage) -- Configuring incomplete, errors occurred! *** CMake configuration failed [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for ViennaPS_Python Failed to build ViennaPS_Python ERROR: Could not build wheels for ViennaPS_Python, which is required to install pyproject.toml-based projects . This error is due to a conflict with the Ninja build system and Unix Makefiles. To resolve this error, you can remove the build folder and then rerun pip. However, please note that this action will also remove all dependencies if they were installed alongside ViennaPS. ",
    "url": "/inst/troubleshooting.html#failed-python-package-build",
    
    "relUrl": "/inst/troubleshooting.html#failed-python-package-build"
  },"122": {
    "doc": "Troubleshooting",
    "title": "Python ImportError",
    "content": "The following error can occur when trying to import the ViennaPS Python package: . ImportError: arg(): could not convert default argument 'boundary: viennahrle::BoundaryType' in method '&lt;class 'viennaps2d.viennaps2d.Domain'&gt;.__init__' into a Python object (type not registered yet?) . This error indicates the your ViennaPS Python package is not compatible with the installed ViennaLS Python package. This can happen if you have installed the ViennaLS Python package from PyPI and then built the ViennaPS Python package from source. To resolve this issue, you can either uninstall the ViennaPS Python package or build the ViennaLS Python package from source as well. Alternatively, you can install the ViennaPS Python package from PyPI, which will ensure compatibility with the installed ViennaLS Python package. To do this, run the following command: . pip install ViennaPS . This will install the latest version of the ViennaPS Python package from PyPI, which should be compatible with the installed ViennaLS Python package. Table of compatibility between ViennaPS and ViennaLS versions: . | ViennaPS Package | ViennaLS Package | Compatible | . | Local Build | Local Build | Yes ✅ | . | Local Build | PyPI | No ❌ | . | PyPI | Local Build | No ❌ | . | PyPI | PyPI | Yes ✅ | . ",
    "url": "/inst/troubleshooting.html#python-importerror",
    
    "relUrl": "/inst/troubleshooting.html#python-importerror"
  },"123": {
    "doc": "Troubleshooting",
    "title": "Windows Python DLL ImportError",
    "content": "If you see the following error when importing the ViennaPS Python package: . ImportError: DLL load failed while importing viennaps2d: The specified module could not be found. This usually means that a required shared library (.dll) is missing. The most common cause on Windows is a missing OpenMP runtime. Solution . Make sure the OpenMP runtime is available on your system. Specifically, the file libomp140.x86_64.dll must be accessible through your system PATH. You can get it from: . | Visual Studio (in debug_nonredist folder) | Prebuilt LLVM distributions for Windows | . After downloading or locating the DLL: . | Either copy it into the folder containing viennaps2d.cp*.pyd | Or add the folder containing the DLL to your system PATH | . Once the DLL is accessible, the import should work correctly. ",
    "url": "/inst/troubleshooting.html#windows-python-dll-importerror",
    
    "relUrl": "/inst/troubleshooting.html#windows-python-dll-importerror"
  },"124": {
    "doc": "Units",
    "title": "Units",
    "content": ". Physical models, like the SF6O2 or Fluorocarbon etching models, require the user to specify the units of the input parameters. The user must set the length and time units before creating a model using the units module. The units are global parameters and apply to every model and process in the program. Example usage: . C++ . using namespace viennaps; units::setLengthUnits(units::LengthUnit::NANOMETER) units::setTimeUnits(units::TimeUnit::MINUTE) // the units can also be specified using strings units::setLengthUnits(\"nm\") // or \"nanometer\" units::setTimeUnits(\"min\") // or \"minute\" . Python . # in Python strings have to be used to set the units vps.setLengthUnits(\"nm\") # or \"nanometer\" vps.setTimeUnits(\"min\") # or \"minute\" . ",
    "url": "/misc/units.html",
    
    "relUrl": "/misc/units.html"
  },"125": {
    "doc": "Velocity Field",
    "title": "Velocity Field",
    "content": ". ",
    "url": "/models/custom/velocityField.html",
    
    "relUrl": "/models/custom/velocityField.html"
  },"126": {
    "doc": "Velocity Field",
    "title": "Surface Velocity Extension",
    "content": "| Option | Description | . | 0 | Do not translate level set ID to surface ID. This should be enabled if the surface velocity is only provided in the psVelocityField class and not through the psSurfaceModel class. | . | 1 | Use unordered map to translate level set ID to surface ID. | . | 2 | Use KD-tree to translate level set ID to surface ID. The KD-tree uses a nearest neighbor lookup to determine the closest surface point and according velocity. | . ",
    "url": "/models/custom/velocityField.html#surface-velocity-extension",
    
    "relUrl": "/models/custom/velocityField.html#surface-velocity-extension"
  },"127": {
    "doc": "Volume Mesh",
    "title": "Volume Mesh",
    "content": ". Volume meshes can be saved using the domain member function saveVolumeMesh. The mesh is solely for visualization purposes and can not be used for further simulations. Example usage: . C++ . auto domain = ps::SmartPointer&lt;ps::Domain&lt;NumericType, D&gt;&gt;::New(); ... // create geometry in domain ... domain-&gt;saveVolumeMesh(\"fileName\"); . Python: . domain = vps.Domain() ... # create geometry in domain ... domain.saveVolumeMesh(fileName=\"fileName\") . ",
    "url": "/output/volume.html",
    
    "relUrl": "/output/volume.html"
  },"128": {
    "doc": "Volume",
    "title": "Volume",
    "content": ". A Cell-Set (CS) is used to store and track volume information in the domain. The CS is stored over the whole simulation domain, above and/or below the surface described by the Level-Set. It uses the same grid as the Level-Set, such that each Level-Set grid point acts as the corner of the cells around the point. To determine which material region a cell lies in, the LS values at the cell corner of the material interface are inspected. If the sum of the values is negative the cell belongs to the underlying material, otherwise it represents the material on the other side of the interface. To find a cell in which an arbitrary point in space resides, a bounding volume hierarchy (BVH) is built on top of the CS. This allows for fast access to random cells in the CS. Additionally, cell-neighbor relations are established when setting up the CS. This allows for quick access to neighbor cells. ",
    "url": "/domain/volume.html",
    
    "relUrl": "/domain/volume.html"
  },"129": {
    "doc": "Volume",
    "title": "How to use the Cell-Set",
    "content": "To generate the CS from your domain, use the function: . auto domain = SmartPointer&lt;Domain&lt;NumericType, D&gt;&gt;::New() ... // Add level-sets to domain ... domain-&gt;generateCellSet(position, material, isCellSetAboveSurface) . The position parameter describes the location of the cell set surface. With the parameter isCellSetAboveSurface one can specify whether the Cell-Set should be placed above or below the surface. If the Cell-Set is above the surface it covers all material in the domain and the position parameter should be set higher than the highest surface point in the domain. ",
    "url": "/domain/volume.html#how-to-use-the-cell-set",
    
    "relUrl": "/domain/volume.html#how-to-use-the-cell-set"
  },"130": {
    "doc": "Volume",
    "title": "Related Examples",
    "content": ". | ViennaCS | Oxide Regrowth | . ",
    "url": "/domain/volume.html#related-examples",
    
    "relUrl": "/domain/volume.html#related-examples"
  }
}
