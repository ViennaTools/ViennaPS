/**
 * This example demonstrates how to use a CSV datasource in combination with
 * rectilinear grid interpolation. The CSV file contains data of a rectilinear
 * data grid (3 input dimensions + 1 output dimension). In this example the
 * rectilinear grid interpolation class is configured to also allow linear
 * extrapolation outside of the provided domain (by calling the constructor with
 * `true`)
 */
#include <filesystem>
#include <iostream>
#include <string>

#include <compact/psCSVDataSource.hpp>
#include <compact/psCSVWriter.hpp>

#include <compact/psNearestNeighborsInterpolation.hpp>
#include <compact/psRectilinearGridInterpolation.hpp>

#include <compact/psDataScaler.hpp>

namespace fs = std::filesystem;

template <typename DataSource, typename Estimator, typename SizeType>
void doEstimation(DataSource &dataSource, Estimator &estimator,
                  SizeType numSamples, SizeType InputDim) {
  using NumericType = typename DataSource::ItemType::value_type;
  if (estimator.initialize()) {
    std::vector<std::vector<NumericType>> data;
    for (int i = 0; i < numSamples; ++i)
      for (int j = 0; j < numSamples; ++j) {
        std::vector<NumericType> x(InputDim);
        // Extrapolate
        x[0] = .1 + i * (.8 - .1) / (numSamples - 1);
        x[1] = -6. + j * (8. + 6.) / (numSamples - 1);

        auto estimateOpt = estimator.estimate(x);
        if (!estimateOpt)
          continue;

        // We use structural bindings to directly unpack the tuple
        auto [value, _] = estimateOpt.value();
        data.emplace_back(std::vector{x[0], x[1], value[0]});
      }
    dataSource.setData(data);
    dataSource.sync();
  }
}

int main(int argc, char *argv[]) {
  using NumericType = double;

  fs::path dataPath = ".";

  if (argc > 1) {
    dataPath = fs::path{argv[1]};
  }

  int numSamples = 40;

  {
    psCSVDataSource<NumericType> dataSource(
        (dataPath / "griddata.csv").string());

    // Quick demo of the positional and named parameters feature
    std::cout << "Positional parameters: ";
    for (auto value : dataSource.getPositionalParameters()) {
      std::cout << value << ',';
    }
    std::cout << std::endl;

    std::cout << "Named parameters: ";
    auto namedParameters = dataSource.getNamedParameters();
    for (auto [key, value] : namedParameters) {
      std::cout << key << '=' << value << ',';
    }
    std::cout << std::endl;

    // Use the input dimension provided as parameter in the CSV file
    int InputDim;
    if (namedParameters.find("InputDimension") != namedParameters.end()) {
      InputDim = namedParameters["InputDimension"];
    } else {
      std::cout << "'InputDimension' missing from named parameters in provided "
                   "file!\n";
      return EXIT_FAILURE;
    }

    int OutputDim;
    if (namedParameters.find("OutputDimension") != namedParameters.end()) {
      OutputDim = namedParameters["OutputDimension"];
    } else {
      std::cout << "'OutputDimension' missing from named parameters in "
                   "provided file!\n";
      return EXIT_FAILURE;
    }

    // End of parameter demo

    psRectilinearGridInterpolation<NumericType> estimator;
    estimator.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.getData();
    estimator.setData(data);

    psCSVDataSource<NumericType> writer("grid_output.csv");
    writer.setHeader(
        "x, y, z, data\nData generated by rectilinear interpolation "
        "on rectilinear grid");

    doEstimation(writer, estimator, numSamples, InputDim);
  }

  int InputDim = 2;
  int OutputDim = 1;

  {
    psCSVDataSource<NumericType> dataSource(
        (dataPath / "scatterdata.csv").string());

    int numberOfNeighbors = 5;
    NumericType distanceExponent = 2.;

    psNearestNeighborsInterpolation<NumericType> estimator;
    estimator.setDistanceExponent(distanceExponent);
    estimator.setNumberOfNeighbors(numberOfNeighbors);
    estimator.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.getData();
    estimator.setData(data);

    psCSVDataSource<NumericType> writer("nn_std_output.csv");
    writer.setHeader("x, y, z, data\nData generated by nearest neighbors "
                     "interpolation using standard deviation scaling");

    doEstimation(writer, estimator, numSamples, InputDim);
  }

  {
    psCSVDataSource<NumericType> dataSource(
        (dataPath / "scatterdata.csv").string());

    int numberOfNeighbors = 5;
    NumericType distanceExponent = 1. / 5.;

    psNearestNeighborsInterpolation<NumericType,
                                    psMedianDistanceScaler<NumericType>>
        estimator;
    estimator.setDistanceExponent(distanceExponent);
    estimator.setNumberOfNeighbors(numberOfNeighbors);
    estimator.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.getData();
    estimator.setData(data);

    psCSVDataSource<NumericType> writer("nn_median_output.csv");
    writer.setHeader("x, y, z, data\nData generated by nearest neighbors "
                     "interpolation using median distance scaling.");

    doEstimation(writer, estimator, numSamples, InputDim);
  }

  return EXIT_SUCCESS;
}
