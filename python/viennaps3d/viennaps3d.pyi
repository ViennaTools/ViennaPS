import collections.abc
import typing
import viennals3d.viennals3d
from _typeshed import Incomplete
from typing import ClassVar, overload

D: int
__version__: str
version: str

class AdvectionCallback:
    domain: Incomplete
    def __init__(self) -> None: ...
    def applyPostAdvect(self, arg0: typing.SupportsFloat) -> bool: ...
    def applyPreAdvect(self, arg0: typing.SupportsFloat) -> bool: ...

class AdvectionParameters:
    checkDissipation: bool
    dissipationAlpha: float
    ignoreVoids: bool
    integrationScheme: viennals3d.viennals3d.IntegrationSchemeEnum
    timeStepRatio: float
    velocityOutput: bool
    def __init__(self) -> None: ...

class AnisotropicProcess(ProcessModel):
    @overload
    def __init__(
        self, materials: collections.abc.Sequence[tuple[Material, typing.SupportsFloat]]
    ) -> None: ...
    @overload
    def __init__(
        self,
        direction100,
        direction010,
        rate100: typing.SupportsFloat,
        rate110: typing.SupportsFloat,
        rate111: typing.SupportsFloat,
        rate311: typing.SupportsFloat,
        materials: collections.abc.Sequence[tuple[Material, typing.SupportsFloat]],
    ) -> None: ...

class AtomicLayerProcess:
    def __init__(self) -> None: ...
    def apply(self) -> None: ...
    def disableRandomSeeds(self) -> None: ...
    def enableRandomSeeds(self) -> None: ...
    def setCoverageTimeStep(self, arg0: typing.SupportsFloat) -> None: ...
    def setDesorptionRates(
        self, arg0: collections.abc.Sequence[typing.SupportsFloat]
    ) -> None: ...
    def setDomain(self, *args, **kwargs): ...
    def setIntegrationScheme(
        self, arg0: viennals3d.viennals3d.IntegrationSchemeEnum
    ) -> None: ...
    def setNumCycles(self, arg0: typing.SupportsInt) -> None: ...
    def setNumberOfRaysPerPoint(self, arg0: typing.SupportsInt) -> None: ...
    def setProcessModel(self, arg0: ProcessModel) -> None: ...
    def setPulseTime(self, arg0: typing.SupportsFloat) -> None: ...
    def setSourceDirection(self, arg0) -> None: ...

class BoxDistribution(ProcessModel):
    @overload
    def __init__(
        self,
        halfAxes,
        gridDelta: typing.SupportsFloat,
        mask: viennals3d.viennals3d.Domain,
    ) -> None: ...
    @overload
    def __init__(self, halfAxes, gridDelta: typing.SupportsFloat) -> None: ...

class CF4O2Etching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        ionFlux: typing.SupportsFloat,
        etchantFlux: typing.SupportsFloat,
        oxygenFlux: typing.SupportsFloat,
        polymerFlux: typing.SupportsFloat,
        meanIonEnergy: typing.SupportsFloat = ...,
        sigmaIonEnergy: typing.SupportsFloat = ...,
        ionExponent: typing.SupportsFloat = ...,
        oxySputterYield: typing.SupportsFloat = ...,
        polySputterYield: typing.SupportsFloat = ...,
        etchStopDepth: typing.SupportsFloat = ...,
    ) -> None: ...
    @overload
    def __init__(self, parameters: CF4O2Parameters) -> None: ...
    def getParameters(self) -> CF4O2Parameters: ...
    def setParameters(self, arg0: CF4O2Parameters) -> None: ...

class CF4O2Parameters:
    Ions: CF4O2ParametersIons
    Mask: CF4O2ParametersMask
    Passivation: CF4O2ParametersPassivation
    Si: CF4O2ParametersSi
    SiGe: CF4O2ParametersSiGe
    etchStopDepth: float
    etchantFlux: float
    fluxIncludeSticking: bool
    gamma_C: dict[Material, float]
    gamma_C_oxidized: dict[Material, float]
    gamma_F: dict[Material, float]
    gamma_F_oxidized: dict[Material, float]
    gamma_O: dict[Material, float]
    gamma_O_passivated: dict[Material, float]
    ionFlux: float
    oxygenFlux: float
    polymerFlux: float
    def __init__(self) -> None: ...

class CF4O2ParametersIons:
    exponent: float
    inflectAngle: float
    meanEnergy: float
    minAngle: float
    n_l: float
    sigmaEnergy: float
    def __init__(self) -> None: ...

class CF4O2ParametersMask:
    A_sp: float
    Eth_sp: float
    rho: float
    def __init__(self) -> None: ...

class CF4O2ParametersPassivation:
    A_C_ie: float
    A_O_ie: float
    Eth_C_ie: float
    Eth_O_ie: float
    def __init__(self) -> None: ...

class CF4O2ParametersSi:
    A_ie: float
    A_sp: float
    Eth_ie: float
    Eth_sp: float
    beta_sigma: float
    k_sigma: float
    rho: float
    def __init__(self) -> None: ...

class CF4O2ParametersSiGe:
    A_ie: float
    A_sp: float
    Eth_ie: float
    Eth_sp: float
    beta_sigma: float
    k_sigma: float
    rho: float
    x: float
    def __init__(self) -> None: ...
    def k_sigma_SiGe(self, arg0: typing.SupportsFloat) -> float: ...

class CSVFileProcess(ProcessModel):
    def __init__(
        self,
        ratesFile: str,
        direction,
        offset,
        isotropicComponent: typing.SupportsFloat = ...,
        directionalComponent: typing.SupportsFloat = ...,
        maskMaterials: collections.abc.Sequence[Material] = ...,
        calculateVisibility: bool = ...,
    ) -> None: ...
    def setCustomInterpolator(self, function: collections.abc.Callable) -> None: ...
    def setIDWNeighbors(self, k: typing.SupportsInt = ...) -> None: ...
    @overload
    def setInterpolationMode(self, mode: Interpolation) -> None: ...
    @overload
    def setInterpolationMode(self, mode: str) -> None: ...
    def setOffset(self, offset) -> None: ...

class DenseCellSet:
    def __init__(self) -> None: ...
    @overload
    def addFillingFraction(
        self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat
    ) -> bool: ...
    @overload
    def addFillingFraction(self, arg0, arg1: typing.SupportsFloat) -> bool: ...
    def addFillingFractionInMaterial(
        self, arg0, arg1: typing.SupportsFloat, arg2: typing.SupportsInt
    ) -> bool: ...
    def addScalarData(self, arg0: str, arg1: typing.SupportsFloat) -> None: ...
    def buildNeighborhood(self, forceRebuild: bool = ...) -> None: ...
    def clear(self) -> None: ...
    def fromLevelSets(
        self,
        levelSets: collections.abc.Sequence[viennals3d.viennals3d.Domain],
        materialMap: viennals3d.viennals3d.MaterialMap = ...,
        depth: typing.SupportsFloat = ...,
    ) -> None: ...
    def getAverageFillingFraction(self, arg0, arg1: typing.SupportsFloat) -> float: ...
    def getBoundingBox(self, *args, **kwargs): ...
    def getCellCenter(self, *args, **kwargs): ...
    def getCellGrid(self) -> viennals3d.viennals3d.Mesh: ...
    def getDepth(self) -> float: ...
    def getElement(self, *args, **kwargs): ...
    def getElements(self, *args, **kwargs): ...
    def getFillingFraction(self, arg0) -> float: ...
    def getFillingFractions(self) -> list[float]: ...
    def getGridDelta(self) -> float: ...
    def getIndex(self, arg0) -> int: ...
    def getNeighbors(self, *args, **kwargs): ...
    def getNode(self, *args, **kwargs): ...
    def getNodes(self, *args, **kwargs): ...
    def getNumberOfCells(self) -> int: ...
    def getScalarData(self, arg0: str) -> list[float]: ...
    def getScalarDataLabels(self) -> list[str]: ...
    def getSurface(self) -> viennals3d.viennals3d.Domain: ...
    def readCellSetData(self, arg0: str) -> None: ...
    def setCellSetPosition(self, arg0: bool) -> None: ...
    def setCoverMaterial(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def setFillingFraction(
        self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat
    ) -> bool: ...
    @overload
    def setFillingFraction(self, arg0, arg1: typing.SupportsFloat) -> bool: ...
    def setPeriodicBoundary(self, arg0) -> None: ...
    def updateMaterials(self) -> None: ...
    def updateSurface(self) -> None: ...
    def writeCellSetData(self, arg0: str) -> None: ...
    def writeVTU(self, arg0: str) -> None: ...

class DirectionalProcess(ProcessModel):
    @overload
    def __init__(
        self,
        direction,
        directionalVelocity: typing.SupportsFloat,
        isotropicVelocity: typing.SupportsFloat = ...,
        maskMaterial: Material = ...,
        calculateVisibility: bool = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        direction,
        directionalVelocity: typing.SupportsFloat,
        isotropicVelocity: typing.SupportsFloat,
        maskMaterial: collections.abc.Sequence[Material],
        calculateVisibility: bool = ...,
    ) -> None: ...
    @overload
    def __init__(self, rateSets: collections.abc.Sequence[RateSet]) -> None: ...
    @overload
    def __init__(self, rateSet: RateSet) -> None: ...

class Domain:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, domain: Domain) -> None: ...
    @overload
    def __init__(
        self,
        gridDelta: typing.SupportsFloat,
        xExtent: typing.SupportsFloat,
        yExtent: typing.SupportsFloat,
        boundary: viennals3d.viennals3d.BoundaryConditionEnum = ...,
    ) -> None: ...
    @overload
    def __init__(
        self, bounds, boundaryConditions, gridDelta: typing.SupportsFloat = ...
    ) -> None: ...
    @overload
    def addMetaData(self, arg0: str, arg1: typing.SupportsFloat) -> None: ...
    @overload
    def addMetaData(
        self, arg0: str, arg1: collections.abc.Sequence[typing.SupportsFloat]
    ) -> None: ...
    @overload
    def addMetaData(
        self,
        arg0: collections.abc.Mapping[
            str, collections.abc.Sequence[typing.SupportsFloat]
        ],
    ) -> None: ...
    def applyBooleanOperation(
        self, arg0: viennals3d.viennals3d.Domain, arg1
    ) -> None: ...
    def clear(self) -> None: ...
    def clearMetaData(self, clearDomainData: bool = ...) -> None: ...
    def deepCopy(self, arg0: Domain) -> None: ...
    @staticmethod
    def disableMetaData() -> None: ...
    def duplicateTopLevelSet(self, arg0: Material) -> None: ...
    @staticmethod
    def enableMetaData(level: MetaDataLevel = ...) -> None: ...
    def generateCellSet(
        self, arg0: typing.SupportsFloat, arg1: Material, arg2: bool
    ) -> None: ...
    def getBoundaryConditions(self, *args, **kwargs): ...
    def getBoundingBox(self, *args, **kwargs): ...
    def getCellSet(self) -> DenseCellSet: ...
    def getGrid(self) -> viennals3d.viennals3d.hrleGrid: ...
    def getGridDelta(self) -> float: ...
    def getLevelSets(self) -> list[viennals3d.viennals3d.Domain]: ...
    def getMaterialMap(self, *args, **kwargs): ...
    def getMetaData(self) -> dict[str, list[float]]: ...
    def getSetup(self, *args, **kwargs): ...
    def insertNextLevelSet(
        self, levelset: viennals3d.viennals3d.Domain, wrapLowerLevelSet: bool = ...
    ) -> None: ...
    def insertNextLevelSetAsMaterial(
        self,
        levelSet: viennals3d.viennals3d.Domain,
        material: Material,
        wrapLowerLevelSet: bool = ...,
    ) -> None: ...
    def print(self, arg0, arg1: bool) -> None: ...
    def removeLevelSet(self, arg0: typing.SupportsInt, arg1: bool) -> None: ...
    def removeMaterial(self, arg0: Material) -> None: ...
    def removeTopLevelSet(self) -> None: ...
    def saveHullMesh(
        self, filename: str, wrappingLayerEpsilon: typing.SupportsFloat = ...
    ) -> None: ...
    def saveLevelSetMesh(
        self, filename: str, width: typing.SupportsInt = ...
    ) -> None: ...
    def saveLevelSets(self, filename: str) -> None: ...
    def saveSurfaceMesh(self, filename: str, addMaterialIds: bool = ...) -> None: ...
    def saveVolumeMesh(
        self, filename: str, wrappingLayerEpsilon: typing.SupportsFloat = ...
    ) -> None: ...
    def setMaterialMap(self, arg0) -> None: ...
    def setup(
        self,
        gridDelta: typing.SupportsFloat,
        xExtent: typing.SupportsFloat,
        yExtent: typing.SupportsFloat = ...,
        boundary: viennals3d.viennals3d.BoundaryConditionEnum = ...,
    ) -> None: ...

class DomainSetup:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        gridDelta: typing.SupportsFloat,
        xExtent: typing.SupportsFloat,
        yExtent: typing.SupportsFloat,
        boundary: viennals3d.viennals3d.BoundaryConditionEnum = ...,
    ) -> None: ...
    def boundaryCons(self, *args, **kwargs): ...
    def bounds(self, *args, **kwargs): ...
    def check(self) -> None: ...
    def grid(self) -> viennals3d.viennals3d.hrleGrid: ...
    def gridDelta(self) -> float: ...
    def halveXAxis(self) -> None: ...
    def halveYAxis(self) -> None: ...
    def hasPeriodicBoundary(self) -> bool: ...
    def isValid(self) -> bool: ...
    def print(self) -> None: ...
    def xExtent(self) -> float: ...
    def yExtent(self) -> float: ...

class FaradayCageEtching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maskMaterials: collections.abc.Sequence[Material]) -> None: ...
    @overload
    def __init__(
        self,
        maskMaterials: collections.abc.Sequence[Material],
        parameters: FaradayCageParameters,
    ) -> None: ...
    def getParameters(self) -> FaradayCageParameters: ...
    def setParameters(self, arg0: FaradayCageParameters) -> None: ...

class FaradayCageParameters:
    cageAngle: float
    ibeParams: IBEParameters
    def __init__(self) -> None: ...

class FluorocarbonEtching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        ionFlux: typing.SupportsFloat,
        etchantFlux: typing.SupportsFloat,
        polyFlux: typing.SupportsFloat,
        meanIonEnergy: typing.SupportsFloat = ...,
        sigmaIonEnergy: typing.SupportsFloat = ...,
        ionExponent: typing.SupportsFloat = ...,
        deltaP: typing.SupportsFloat = ...,
        etchStopDepth: typing.SupportsFloat = ...,
    ) -> None: ...
    @overload
    def __init__(self, parameters: FluorocarbonParameters) -> None: ...
    def getParameters(self) -> FluorocarbonParameters: ...
    def setParameters(self, arg0: FluorocarbonParameters) -> None: ...

class FluorocarbonParameters:
    Ions: FluorocarbonParametersIons
    Mask: FluorocarbonParametersMask
    Polymer: FluorocarbonParametersPolymer
    Si: FluorocarbonParametersSi
    Si3N4: FluorocarbonParametersSi3N4
    SiO2: FluorocarbonParametersSiO2
    delta_p: float
    etchStopDepth: float
    etchantFlux: float
    ionFlux: float
    polyFlux: float
    def __init__(self) -> None: ...

class FluorocarbonParametersIons:
    exponent: float
    inflectAngle: float
    meanEnergy: float
    minAngle: float
    n_l: float
    sigmaEnergy: float
    def __init__(self) -> None: ...

class FluorocarbonParametersMask:
    A_sp: float
    B_sp: float
    Eth_sp: float
    beta_e: float
    beta_p: float
    rho: float
    def __init__(self) -> None: ...

class FluorocarbonParametersPolymer:
    A_ie: float
    Eth_ie: float
    rho: float
    def __init__(self) -> None: ...

class FluorocarbonParametersSi:
    A_ie: float
    A_sp: float
    B_sp: float
    E_a: float
    Eth_ie: float
    Eth_sp: float
    K: float
    rho: float
    def __init__(self) -> None: ...

class FluorocarbonParametersSi3N4:
    A_ie: float
    A_sp: float
    B_sp: float
    E_a: float
    Eth_ie: float
    Eth_sp: float
    K: float
    rho: float
    def __init__(self) -> None: ...

class FluorocarbonParametersSiO2:
    A_ie: float
    A_sp: float
    B_sp: float
    E_a: float
    Eth_ie: float
    Eth_sp: float
    K: float
    rho: float
    def __init__(self) -> None: ...

class GDSGeometry:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, gridDelta: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, gridDelta: typing.SupportsFloat, boundaryConditions) -> None: ...
    def addBlur(
        self,
        sigmas: collections.abc.Sequence[typing.SupportsFloat],
        weights: collections.abc.Sequence[typing.SupportsFloat],
        threshold: typing.SupportsFloat = ...,
        delta: typing.SupportsFloat = ...,
        gridRefinement: typing.SupportsInt = ...,
    ) -> None: ...
    def getAllLayers(self) -> set[int]: ...
    def getBounds(self, *args, **kwargs): ...
    def getNumberOfStructures(self) -> int: ...
    def layerToLevelSet(
        self,
        layer: typing.SupportsInt,
        baseHeight: typing.SupportsFloat = ...,
        height: typing.SupportsFloat = ...,
        mask: bool = ...,
        blurLayer: bool = ...,
    ) -> viennals3d.viennals3d.Domain: ...
    def print(self) -> None: ...
    def setBoundaryConditions(
        self,
        arg0: collections.abc.Sequence[viennals3d.viennals3d.BoundaryConditionEnum],
    ) -> None: ...
    def setBoundaryPadding(
        self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat
    ) -> None: ...
    def setGridDelta(self, arg0: typing.SupportsFloat) -> None: ...

class GDSReader:
    def __init__(self) -> None: ...
    def apply(self) -> None: ...
    def setFileName(self, arg0: str) -> None: ...
    def setGeometry(self, *args, **kwargs): ...

class GeometryFactory:
    def __init__(self, *args, **kwargs) -> None: ...
    def makeBoxStencil(
        self,
        position,
        width: typing.SupportsFloat,
        height: typing.SupportsFloat,
        angle: typing.SupportsFloat = ...,
        length: typing.SupportsFloat = ...,
    ) -> viennals3d.viennals3d.Domain: ...
    def makeCylinderStencil(
        self,
        position,
        radius: typing.SupportsFloat,
        height: typing.SupportsFloat,
        angle: typing.SupportsFloat = ...,
    ) -> viennals3d.viennals3d.Domain: ...
    def makeMask(
        self, base: typing.SupportsFloat, height: typing.SupportsFloat
    ) -> viennals3d.viennals3d.Domain: ...
    def makeSubstrate(
        self, base: typing.SupportsFloat
    ) -> viennals3d.viennals3d.Domain: ...

class HBrO2Etching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        ionFlux: typing.SupportsFloat,
        etchantFlux: typing.SupportsFloat,
        oxygenFlux: typing.SupportsFloat,
        meanIonEnergy: typing.SupportsFloat = ...,
        sigmaIonEnergy: typing.SupportsFloat = ...,
        ionExponent: typing.SupportsFloat = ...,
        oxySputterYield: typing.SupportsFloat = ...,
        etchStopDepth: typing.SupportsFloat = ...,
    ) -> None: ...
    @overload
    def __init__(self, parameters: PlasmaEtchingParameters) -> None: ...
    @staticmethod
    def defaultParameters() -> PlasmaEtchingParameters: ...
    def getParameters(self) -> PlasmaEtchingParameters: ...
    def setParameters(self, arg0: PlasmaEtchingParameters) -> None: ...

class HoleShape:
    __members__: ClassVar[dict] = ...  # read-only
    Full: ClassVar[HoleShape] = ...
    Half: ClassVar[HoleShape] = ...
    Quarter: ClassVar[HoleShape] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IBEParameters:
    exponent: float
    inflectAngle: float
    materialPlaneWaferRate: dict[Material, float]
    meanEnergy: float
    minAngle: float
    n_l: float
    planeWaferRate: float
    redepositionRate: float
    redepositionThreshold: float
    sigmaEnergy: float
    thresholdEnergy: float
    tiltAngle: float
    yieldFunction: collections.abc.Callable[[typing.SupportsFloat], float]
    def __init__(self) -> None: ...

class Interpolation:
    __members__: ClassVar[dict] = ...  # read-only
    CUSTOM: ClassVar[Interpolation] = ...
    IDW: ClassVar[Interpolation] = ...
    LINEAR: ClassVar[Interpolation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IonBeamEtching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maskMaterials: collections.abc.Sequence[Material]) -> None: ...
    @overload
    def __init__(
        self,
        maskMaterials: collections.abc.Sequence[Material],
        parameters: IBEParameters,
    ) -> None: ...
    def getParameters(self) -> IBEParameters: ...
    def setParameters(self, arg0: IBEParameters) -> None: ...

class IsotropicProcess(ProcessModel):
    @overload
    def __init__(
        self, rate: typing.SupportsFloat = ..., maskMaterial: Material = ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        rate: typing.SupportsFloat,
        maskMaterial: collections.abc.Sequence[Material],
    ) -> None: ...
    @overload
    def __init__(
        self,
        materialRates: collections.abc.Mapping[Material, typing.SupportsFloat],
        defaultRate: typing.SupportsFloat = ...,
    ) -> None: ...

class Length:
    def __init__(self, *args, **kwargs) -> None: ...
    def convertAngstrom(self) -> float: ...
    def convertCentimeter(self) -> float: ...
    def convertMeter(self) -> float: ...
    def convertMicrometer(self) -> float: ...
    def convertMillimeter(self) -> float: ...
    def convertNanometer(self) -> float: ...
    @staticmethod
    def getInstance() -> Length: ...
    @staticmethod
    def setUnit(arg0: str) -> None: ...
    def toShortString(self) -> str: ...
    def toString(self) -> str: ...

class LogLevel:
    __members__: ClassVar[dict] = ...  # read-only
    DEBUG: ClassVar[LogLevel] = ...
    ERROR: ClassVar[LogLevel] = ...
    INFO: ClassVar[LogLevel] = ...
    INTERMEDIATE: ClassVar[LogLevel] = ...
    TIMING: ClassVar[LogLevel] = ...
    WARNING: ClassVar[LogLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Logger:
    def __init__(self, *args, **kwargs) -> None: ...
    def addDebug(self, arg0: str) -> Logger: ...
    def addError(self, s: str, shouldAbort: bool = ...) -> Logger: ...
    def addInfo(self, arg0: str) -> Logger: ...
    @overload
    def addTiming(self, arg0: str, arg1: typing.SupportsFloat) -> Logger: ...
    @overload
    def addTiming(
        self, arg0: str, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat
    ) -> Logger: ...
    def addWarning(self, arg0: str) -> Logger: ...
    @staticmethod
    def getInstance() -> Logger: ...
    @staticmethod
    def getLogLevel() -> int: ...
    def print(self) -> None: ...
    @staticmethod
    def setLogLevel(arg0: LogLevel) -> None: ...

class MakeFin:
    @overload
    def __init__(
        self,
        domain: Domain,
        finWidth: float,
        finHeight: float,
        finTaperAngle: float = 0.0,
        maskHeight: float = 0.0,
        maskTaperAngle: float = 0.0,
        halfFin: bool = False,
        material: Material = Material.Si,
        maskMaterial: Material = Material.Mask,
    ) -> None: ...
    @overload
    def __init__(
        self,
        domain: Domain,
        gridDelta: float,
        xExtent: float,
        yExtent: float,
        finWidth: float,
        finHeight: float,
        taperAngle: float = 0.0,
        baseHeight: float = 0.0,
        periodicBoundary: bool = False,
        makeMask: bool = False,
        material: Material = Material.Si,
    ) -> None: ...
    def apply(self) -> None: ...

class MakeHole:
    @overload
    def __init__(
        self,
        domain: Domain,
        holeRadius: float,
        holeDepth: float,
        holeTaperAngle: float = 0.0,
        maskHeight: float = 0.0,
        maskTaperAngle: float = 0.0,
        holeShape: HoleShape = HoleShape.Full,
        material: Material = Material.Si,
        maskMaterial: Material = Material.Mask,
    ) -> None: ...
    @overload
    def __init__(
        self,
        domain: Domain,
        gridDelta: float,
        xExtent: float,
        yExtent: float,
        holeRadius: float,
        holeDepth: float,
        taperingAngle: float = 0.0,
        baseHeight: float = 0.0,
        periodicBoundary: bool = False,
        makeMask: bool = False,
        material: Material = Material.Si,
        holeShape: HoleShape = HoleShape.Full,
    ) -> None: ...
    def apply(self) -> None: ...

class MakePlane:
    @overload
    def __init__(
        self,
        domain: Domain,
        gridDelta: float,
        xExtent: float,
        yExtent: float,
        height: float = 0.0,
        periodicBoundary: bool = False,
        material: Material = Material.Si,
    ) -> None: ...
    @overload
    def __init__(
        self,
        domain: Domain,
        height: float = 0.0,
        material: Material = Material.Si,
        addToExisting: bool = False,
    ) -> None: ...
    def apply(self) -> None: ...

class MakeStack:
    @overload
    def __init__(
        self,
        domain: Domain,
        numLayers: int,
        layerHeight: float,
        substrateHeight: float = 0,
        holeRadius: float = 0,
        trenchWidth: float = 0,
        maskHeight: float = 0,
        taperAngle: float = 0,
        halfStack: bool = False,
        maskMaterial: Material = Material.Mask,
    ) -> None: ...
    @overload
    def __init__(
        self,
        domain: Domain,
        gridDelta: float,
        xExtent: float,
        yExtent: float,
        numLayers: int,
        layerHeight: float,
        substrateHeight: float,
        holeRadius: float,
        trenchWidth: float,
        maskHeight: float,
        periodicBoundary: bool = False,
    ) -> None: ...
    def apply(self) -> None: ...
    def getHeight(self) -> float: ...
    def getTopLayer(self) -> int: ...

class MakeTrench:
    @overload
    def __init__(
        self,
        domain: Domain,
        trenchWidth: float,
        trenchDepth: float,
        trenchTaperAngle: float = 0.0,
        maskHeight: float = 0.0,
        maskTaperAngle: float = 0.0,
        halfTrench: bool = False,
        material: Material = Material.Si,
        maskMaterial: Material = Material.Mask,
    ) -> None: ...
    @overload
    def __init__(
        self,
        domain: Domain,
        gridDelta: float,
        xExtent: float,
        yExtent: float,
        trenchWidth: float,
        trenchDepth: float,
        taperingAngle: float = 0.0,
        baseHeight: float = 0.0,
        periodicBoundary: bool = False,
        makeMask: bool = False,
        material: Material = Material.Si,
    ) -> None: ...
    def apply(self) -> None: ...

class Material:
    __members__: ClassVar[dict] = ...  # read-only
    Air: ClassVar[Material] = ...
    Al2O3: ClassVar[Material] = ...
    Cu: ClassVar[Material] = ...
    Dielectric: ClassVar[Material] = ...
    GAS: ClassVar[Material] = ...
    GaN: ClassVar[Material] = ...
    HfO2: ClassVar[Material] = ...
    Mask: ClassVar[Material] = ...
    Metal: ClassVar[Material] = ...
    PolySi: ClassVar[Material] = ...
    Polymer: ClassVar[Material] = ...
    Si: ClassVar[Material] = ...
    Si3N4: ClassVar[Material] = ...
    SiC: ClassVar[Material] = ...
    SiGe: ClassVar[Material] = ...
    SiN: ClassVar[Material] = ...
    SiO2: ClassVar[Material] = ...
    SiON: ClassVar[Material] = ...
    TiN: ClassVar[Material] = ...
    Undefined: ClassVar[Material] = ...
    W: ClassVar[Material] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MaterialMap:
    def __init__(self) -> None: ...
    def getMaterialAtIdx(self, arg0: typing.SupportsInt) -> Material: ...
    def getMaterialMap(self) -> viennals3d.viennals3d.MaterialMap: ...
    @staticmethod
    def getMaterialName(arg0: Material) -> str: ...
    def insertNextMaterial(self, material: Material = ...) -> None: ...
    @staticmethod
    def isMaterial(arg0: typing.SupportsFloat, arg1: Material) -> bool: ...
    @staticmethod
    def mapToMaterial(arg0: typing.SupportsFloat) -> Material: ...
    def size(self) -> int: ...

class MetaDataLevel:
    __members__: ClassVar[dict] = ...  # read-only
    DOMAIN: ClassVar[MetaDataLevel] = ...
    FULL: ClassVar[MetaDataLevel] = ...
    NONE: ClassVar[MetaDataLevel] = ...
    PROCESS: ClassVar[MetaDataLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MultiParticleProcess(ProcessModel):
    def __init__(self) -> None: ...
    def addIonParticle(
        self,
        sourcePower: typing.SupportsFloat,
        thetaRMin: typing.SupportsFloat = ...,
        thetaRMax: typing.SupportsFloat = ...,
        minAngle: typing.SupportsFloat = ...,
        B_sp: typing.SupportsFloat = ...,
        meanEnergy: typing.SupportsFloat = ...,
        sigmaEnergy: typing.SupportsFloat = ...,
        thresholdEnergy: typing.SupportsFloat = ...,
        inflectAngle: typing.SupportsFloat = ...,
        n: typing.SupportsFloat = ...,
        label: str = ...,
    ) -> None: ...
    @overload
    def addNeutralParticle(
        self, stickingProbability: typing.SupportsFloat, label: str = ...
    ) -> None: ...
    @overload
    def addNeutralParticle(
        self,
        materialSticking: collections.abc.Mapping[Material, typing.SupportsFloat],
        defaultStickingProbability: typing.SupportsFloat = ...,
        label: str = ...,
    ) -> None: ...
    def setRateFunction(
        self,
        arg0: collections.abc.Callable[
            [collections.abc.Sequence[typing.SupportsFloat], Material], float
        ],
    ) -> None: ...

class NormalizationType:
    __members__: ClassVar[dict] = ...  # read-only
    MAX: ClassVar[NormalizationType] = ...
    SOURCE: ClassVar[NormalizationType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class OxideRegrowth(ProcessModel):
    def __init__(
        self,
        nitrideEtchRate: typing.SupportsFloat,
        oxideEtchRate: typing.SupportsFloat,
        redepositionRate: typing.SupportsFloat,
        redepositionThreshold: typing.SupportsFloat,
        redepositionTimeInt: typing.SupportsFloat,
        diffusionCoefficient: typing.SupportsFloat,
        sinkStrength: typing.SupportsFloat,
        scallopVelocity: typing.SupportsFloat,
        centerVelocity: typing.SupportsFloat,
        topHeight: typing.SupportsFloat,
        centerWidth: typing.SupportsFloat,
        stabilityFactor: typing.SupportsFloat,
    ) -> None: ...

class Particle:
    def __init__(self, *args, **kwargs) -> None: ...
    def getLocalDataLabels(self) -> list[str]: ...
    def getSourceDistributionPower(self) -> float: ...
    def initNew(self, arg0) -> None: ...
    def surfaceCollision(
        self,
        arg0: typing.SupportsFloat,
        arg1,
        arg2,
        arg3: typing.SupportsInt,
        arg4: typing.SupportsInt,
        arg5,
        arg6,
        arg7,
    ) -> None: ...
    def surfaceReflection(self, *args, **kwargs): ...

class Planarize:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, geometry: Domain, cutoffHeight: typing.SupportsFloat = ...
    ) -> None: ...
    def apply(self) -> None: ...
    def setCutoffPosition(self, arg0: typing.SupportsFloat) -> None: ...
    def setDomain(self, arg0: Domain) -> None: ...

class PlasmaEtchingParameters:
    Ions: PlasmaEtchingParametersIons
    Mask: PlasmaEtchingParametersMask
    Passivation: PlasmaEtchingParametersPassivation
    Substrate: PlasmaEtchingParametersSubstrate
    beta_E: dict[int, float]
    beta_P: dict[int, float]
    etchStopDepth: float
    etchantFlux: float
    ionFlux: float
    passivationFlux: float
    def __init__(self) -> None: ...

class PlasmaEtchingParametersIons:
    exponent: float
    inflectAngle: float
    meanEnergy: float
    minAngle: float
    n_l: float
    sigmaEnergy: float
    thetaRMax: float
    thetaRMin: float
    def __init__(self) -> None: ...

class PlasmaEtchingParametersMask:
    A_sp: float
    B_sp: float
    Eth_sp: float
    rho: float
    def __init__(self) -> None: ...

class PlasmaEtchingParametersPassivation:
    A_ie: float
    Eth_ie: float
    def __init__(self) -> None: ...

class PlasmaEtchingParametersPolymer:
    A_sp: float
    B_sp: float
    Eth_sp: float
    rho: float
    def __init__(self) -> None: ...

class PlasmaEtchingParametersSubstrate:
    A_ie: float
    A_sp: float
    B_ie: float
    B_sp: float
    Eth_ie: float
    Eth_sp: float
    beta_sigma: float
    k_sigma: float
    rho: float
    def __init__(self) -> None: ...

class Process:
    def __init__(self) -> None: ...
    def apply(self) -> None: ...
    def calculateFlux(self) -> viennals3d.viennals3d.Mesh: ...
    def disableAdvectionVelocityOutput(self) -> None: ...
    def disableFluxSmoothing(self) -> None: ...
    def disableRandomSeeds(self) -> None: ...
    def enableAdvectionVelocityOutput(self) -> None: ...
    def enableFluxSmoothing(self) -> None: ...
    def enableRandomSeeds(self) -> None: ...
    def getAdvectionParameters(self) -> AdvectionParameters: ...
    def getProcessDuration(self) -> float: ...
    def getRayTracingParameters(self) -> RayTracingParameters: ...
    def setAdvectionParameters(self, arg0: AdvectionParameters) -> None: ...
    def setCoverageDeltaThreshold(self, arg0: typing.SupportsFloat) -> None: ...
    def setDomain(self, *args, **kwargs): ...
    def setIntegrationScheme(
        self, arg0: viennals3d.viennals3d.IntegrationSchemeEnum
    ) -> None: ...
    def setMaxCoverageInitIterations(self, arg0: typing.SupportsInt) -> None: ...
    def setNumberOfRaysPerPoint(self, arg0: typing.SupportsInt) -> None: ...
    def setProcessDuration(self, arg0: typing.SupportsFloat) -> None: ...
    def setProcessModel(self, arg0: ProcessModel) -> None: ...
    def setRayTracingDiskRadius(self, arg0: typing.SupportsFloat) -> None: ...
    def setRayTracingParameters(self, arg0: RayTracingParameters) -> None: ...
    def setSourceDirection(self, arg0) -> None: ...
    def setTimeStepRatio(self, arg0: typing.SupportsFloat) -> None: ...

class ProcessModel:
    def __init__(self) -> None: ...
    def getAdvectionCallback(self, *args, **kwargs): ...
    def getGeometricModel(self, *args, **kwargs): ...
    def getParticleLogSize(self, arg0: typing.SupportsInt) -> int: ...
    def getParticleTypes(self, *args, **kwargs): ...
    def getPrimaryDirection(self, *args, **kwargs): ...
    def getProcessName(self) -> str | None: ...
    def getSurfaceModel(self, *args, **kwargs): ...
    def getVelocityField(self, *args, **kwargs): ...
    def insertNextParticleType(self, arg0) -> None: ...
    def setAdvectionCallback(self, *args, **kwargs): ...
    def setGeometricModel(self, *args, **kwargs): ...
    def setPrimaryDirection(self, arg0) -> None: ...
    def setProcessName(self, arg0: str) -> None: ...
    def setSurfaceModel(self, arg0) -> None: ...
    def setVelocityField(self, *args, **kwargs): ...

class ProcessParams:
    def __init__(self) -> None: ...
    @overload
    def getScalarData(self, arg0: typing.SupportsInt) -> float: ...
    @overload
    def getScalarData(self, arg0: typing.SupportsInt) -> float: ...
    @overload
    def getScalarData(self, arg0: str) -> float: ...
    @overload
    def getScalarData(self) -> list[float]: ...
    @overload
    def getScalarData(self) -> list[float]: ...
    def getScalarDataIndex(self, arg0: str) -> int: ...
    def getScalarDataLabel(self, arg0: typing.SupportsInt) -> str: ...
    def insertNextScalar(self, arg0: typing.SupportsFloat, arg1: str) -> None: ...

class RateGrid:
    def __init__(self) -> None: ...
    def interpolate(self, coord) -> float: ...
    def loadFromCSV(self, filename: str) -> bool: ...
    def setCustomInterpolator(self, function: collections.abc.Callable) -> None: ...
    def setIDWNeighbors(self, k: typing.SupportsInt) -> None: ...
    @overload
    def setInterpolationMode(self, mode: Interpolation) -> None: ...
    @overload
    def setInterpolationMode(self, mode: str) -> None: ...
    def setOffset(self, offset) -> None: ...

class RateSet:
    calculateVisibility: bool
    direction: Incomplete
    directionalVelocity: float
    isotropicVelocity: float
    maskMaterials: list[Material]
    def __init__(
        self,
        direction=...,
        directionalVelocity: typing.SupportsFloat = ...,
        isotropicVelocity: typing.SupportsFloat = ...,
        maskMaterials: collections.abc.Sequence[Material] = ...,
        calculateVisibility: bool = ...,
    ) -> None: ...
    def print(self) -> None: ...

class RayTracingParameters:
    diskRadius: float
    ignoreFluxBoundaries: bool
    normalizationType: NormalizationType
    raysPerPoint: int
    smoothingNeighbors: int
    sourceDirection: Incomplete
    useRandomSeeds: bool
    def __init__(self) -> None: ...

class Reader:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fileName: str) -> None: ...
    def apply(self) -> Domain: ...
    def setFileName(self, arg0: str) -> None: ...

class SF6C4F8Etching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        ionFlux: typing.SupportsFloat,
        etchantFlux: typing.SupportsFloat,
        meanEnergy: typing.SupportsFloat,
        sigmaEnergy: typing.SupportsFloat,
        ionExponent: typing.SupportsFloat = ...,
        etchStopDepth: typing.SupportsFloat = ...,
    ) -> None: ...
    @overload
    def __init__(self, parameters: PlasmaEtchingParameters) -> None: ...
    @staticmethod
    def defaultParameters() -> PlasmaEtchingParameters: ...
    def getParameters(self) -> PlasmaEtchingParameters: ...
    def setParameters(self, arg0: PlasmaEtchingParameters) -> None: ...

class SF6O2Etching(ProcessModel):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        ionFlux: typing.SupportsFloat,
        etchantFlux: typing.SupportsFloat,
        oxygenFlux: typing.SupportsFloat,
        meanIonEnergy: typing.SupportsFloat = ...,
        sigmaIonEnergy: typing.SupportsFloat = ...,
        ionExponent: typing.SupportsFloat = ...,
        oxySputterYield: typing.SupportsFloat = ...,
        etchStopDepth: typing.SupportsFloat = ...,
    ) -> None: ...
    @overload
    def __init__(self, parameters: PlasmaEtchingParameters) -> None: ...
    @staticmethod
    def defaultParameters() -> PlasmaEtchingParameters: ...
    def getParameters(self) -> PlasmaEtchingParameters: ...
    def setParameters(self, arg0: PlasmaEtchingParameters) -> None: ...

class SingleParticleALD(ProcessModel):
    def __init__(
        self,
        stickingProbability: typing.SupportsFloat,
        numCycles: typing.SupportsFloat,
        growthPerCycle: typing.SupportsFloat,
        totalCycles: typing.SupportsFloat,
        coverageTimeStep: typing.SupportsFloat,
        evFlux: typing.SupportsFloat,
        inFlux: typing.SupportsFloat,
        s0: typing.SupportsFloat,
        gasMFP: typing.SupportsFloat,
    ) -> None: ...

class SingleParticleProcess(ProcessModel):
    @overload
    def __init__(
        self,
        rate: typing.SupportsFloat = ...,
        stickingProbability: typing.SupportsFloat = ...,
        sourceExponent: typing.SupportsFloat = ...,
        maskMaterial: Material = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        rate: typing.SupportsFloat,
        stickingProbability: typing.SupportsFloat,
        sourceExponent: typing.SupportsFloat,
        maskMaterials: collections.abc.Sequence[Material],
    ) -> None: ...
    @overload
    def __init__(
        self,
        materialRates: collections.abc.Mapping[Material, typing.SupportsFloat],
        stickingProbability: typing.SupportsFloat,
        sourceExponent: typing.SupportsFloat,
    ) -> None: ...

class SphereDistribution(ProcessModel):
    @overload
    def __init__(
        self,
        radius: typing.SupportsFloat,
        gridDelta: typing.SupportsFloat,
        mask: viennals3d.viennals3d.Domain,
    ) -> None: ...
    @overload
    def __init__(
        self, radius: typing.SupportsFloat, gridDelta: typing.SupportsFloat
    ) -> None: ...

class TEOSDeposition(ProcessModel):
    def __init__(
        self,
        stickingProbabilityP1: typing.SupportsFloat,
        rateP1: typing.SupportsFloat,
        orderP1: typing.SupportsFloat,
        stickingProbabilityP2: typing.SupportsFloat = ...,
        rateP2: typing.SupportsFloat = ...,
        orderP2: typing.SupportsFloat = ...,
    ) -> None: ...

class TEOSPECVD(ProcessModel):
    def __init__(
        self,
        stickingProbabilityRadical: typing.SupportsFloat,
        depositionRateRadical: typing.SupportsFloat,
        depositionRateIon: typing.SupportsFloat,
        exponentIon: typing.SupportsFloat,
        stickingProbabilityIon: typing.SupportsFloat = ...,
        reactionOrderRadical: typing.SupportsFloat = ...,
        reactionOrderIon: typing.SupportsFloat = ...,
        minAngleIon: typing.SupportsFloat = ...,
    ) -> None: ...

class Time:
    def __init__(self, *args, **kwargs) -> None: ...
    def convertMillisecond(self) -> float: ...
    def convertMinute(self) -> float: ...
    def convertSecond(self) -> float: ...
    @staticmethod
    def getInstance() -> Time: ...
    @staticmethod
    def setUnit(arg0: str) -> None: ...
    def toShortString(self) -> str: ...
    def toString(self) -> str: ...

class ToDiskMesh:
    @overload
    def __init__(self, domain: Domain, mesh: viennals3d.viennals3d.Mesh) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def setDomain(self, arg0: Domain) -> None: ...
    def setMesh(self, arg0: viennals3d.viennals3d.Mesh) -> None: ...

class Writer:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, domain: Domain) -> None: ...
    @overload
    def __init__(self, domain: Domain, fileName: str) -> None: ...
    def apply(self) -> None: ...
    def setDomain(self, arg0: Domain) -> None: ...
    def setFileName(self, arg0: str) -> None: ...

def setNumThreads(arg0: typing.SupportsInt) -> None: ...
