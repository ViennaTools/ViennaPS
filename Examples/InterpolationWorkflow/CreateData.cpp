#include "DimensionExtraction.hpp"
#include "Parameters.hpp"
#include "TrenchDeposition.hpp"

int main(int argc, char *argv[]) {
  using NumericType = double;
  constexpr int D = 2;

  // How long to run the process and at which intervals to do the extraction
  static constexpr NumericType processDuration = 5.0;
  static constexpr NumericType extractionInterval = 1.0;

  // The parameters we are interested in
  std::vector<NumericType> stickingProbabilities = {1., 0.8, 0.3, 0.1};
  std::vector<NumericType> taperAngles = {-2., 0., 2.};

  // The number of heights at which we are going to measure the diameter of the
  // trench
  static constexpr int numberOfSamples = 30;

  // Total number of timesteps during the advection process at which the
  // geometry parameters are extracted.
  static constexpr int numberOfTimesteps =
      processDuration / extractionInterval + 1;

  // The data we are going to store consists of stickingProbability,
  // taperAngle and the sampled geometry descriptors as provided by the
  // extractor.
  static constexpr int dataDimension =
      numberOfTimesteps * (numberOfSamples + 1) + 2;
  printf("Number of extraction timesteps: %d\n", numberOfTimesteps);

  // Instantiate the extractor
  auto extractor = psSmartPointer<DimensionExtraction<NumericType, D>>::New();
  extractor->setNumberOfSamples(numberOfSamples);

  // The locations at which the diameters are extracted (normalized to the
  // trench depth at each timestep)
  auto sampleLocations = extractor->getSampleLocations();

  std::string filename = "output.csv";
  auto writer =
      psSmartPointer<psCSVWriter<NumericType, dataDimension>>::New(filename);

  // Creation of a descriptive/ detailed header
  std::string header = "taperAngle,stickingProbability,";
  for (unsigned j = 0; j < numberOfTimesteps; ++j) {
    auto jstr = std::to_string(j);
    header += "time_" + jstr + ",depth_" + jstr;
    for (unsigned i = 0; i < numberOfSamples - 1; ++i) {
      header += ",diameter_" + jstr + "_" + std::to_string(i);
    }
    if (j != numberOfTimesteps - 1)
      header += ",";
  }
  header += "\nData generated by simple trench deposition example.\nRelative "
            "locations of diameter measurements:";
  header += "\n!" + join(sampleLocations.begin(), sampleLocations.end());

  writer->setHeader(header);
  writer->initialize();

  Parameters<NumericType> params;

  for (auto taperAngle : taperAngles) {
    params.taperAngle = taperAngle;
    for (auto stickingProbability : stickingProbabilities) {
      params.stickingProbability = stickingProbability;
      std::cout << "taperAngle=" << taperAngle
                << ", sticking probability=" << stickingProbability << '\n';

      // Using the advection callback, we can run the extraction at
      // certain pre-defined advection tim esteps.
      NumericType deltaT = extractionInterval / params.stickingProbability;

      auto data = psSmartPointer<std::vector<NumericType>>::New();
      data->push_back(params.taperAngle);
      data->push_back(params.stickingProbability);

      auto advectionCallback =
          psSmartPointer<AdvectionCallback<NumericType, D, dataDimension>>::New(
              deltaT);

      advectionCallback->setExtractor(extractor);
      advectionCallback->setDataPtr(data);

      auto geometry = psSmartPointer<psDomain<NumericType, D>>::New();
      psMakeTrench<NumericType, D>(geometry, params.gridDelta /* grid delta */,
                                   params.xExtent /*x extent*/,
                                   params.yExtent /*y extent*/,
                                   params.trenchWidth /*trench width*/,
                                   params.trenchHeight /*trench height*/,
                                   params.taperAngle /* tapering angle */)
          .apply();

      params.processTime = processDuration / params.stickingProbability;

      executeProcess<NumericType, D>(geometry, params, advectionCallback);

      writer->writeRow(*data);
      writer->flush();
    }
  }

  return EXIT_SUCCESS;
}