/**
 * This example demonstrates how to use a CSV datasource in combination with
 * rectilinear grid interpolation. The CSV file contains data of a rectilinear
 * data grid (3 input dimensions + 1 output dimension). In this example the
 * rectilinear grid interpolation class is configured to also allow linear
 * extrapolation outside of the provided domain (by calling the constructor with
 * `true`)
 */
#include <filesystem>
#include <iostream>
#include <string>

#include <psCSVDataSource.hpp>
#include <psCSVWriter.hpp>
#include <psNearestNeighborsInterpolation.hpp>
#include <psRectilinearGridInterpolation.hpp>

#include <psDataScaler.hpp>

namespace fs = std::filesystem;

int main(int argc, char *argv[]) {
  using NumericType = double;

  fs::path dataPath = ".";

  if (argc > 1) {
    dataPath = fs::path{argv[1]};
  }

  int InputDim = 3;
  int OutputDim = 1;
  int numSamples = 40;

  {
    psCSVDataSource<NumericType> dataSource;
    dataSource.setFilename((dataPath / "griddata.csv").string());

    // Quick demo of the positional and named parameters feature
    std::cout << "Positional parameters: ";
    for (auto value : dataSource.getPositionalParameters()) {
      std::cout << value << ',';
    }
    std::cout << std::endl;

    std::cout << "Named parameters: ";
    for (auto [key, value] : dataSource.getNamedParameters()) {
      std::cout << key << '=' << value << ',';
    }
    std::cout << std::endl;
    // End of parameter demo

    psCSVWriter<NumericType> writer(
        "grid_output.csv",
        "x, y, z, data\nData generated by trilinear interpolation "
        "on rectilinear grid");

    psRectilinearGridInterpolation<NumericType> interpolation;
    interpolation.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.get();
    interpolation.setData(data);

    if (interpolation.initialize() && writer.initialize())
      for (int i = 0; i < numSamples; ++i)
        for (int j = 0; j < numSamples; ++j)
          for (int k = 0; k < numSamples; ++k) {
            std::vector<NumericType> x(InputDim);
            // x[0] = 3. + i * (6. - 3.) / (numSamples - 1);
            // x[1] = -4. + j * (6. + 4.) / (numSamples - 1);
            // x[2] = -4. + k * (-1. + 4.) / (numSamples - 1);

            // Extrapolate
            x[0] = .1 + i * (.8 - .1) / (numSamples - 1);
            x[1] = -6. + j * (8. + 6.) / (numSamples - 1);
            x[2] = -6. + k * (1. + 6.) / (numSamples - 1);

            auto estimateOpt = interpolation.estimate(x);
            if (!estimateOpt)
              continue;

            // We use structural bindings to directly unpack the tuple
            auto [value, isInside] = estimateOpt.value();

            writer.writeRow({x[0], x[1], x[2], value[0]});
          }
  }

  {
    psCSVDataSource<NumericType> dataSource;
    dataSource.setFilename((dataPath / "scatterdata.csv").string());

    int numberOfNeighbors = 5;
    NumericType distanceExponent = 2.;

    psNearestNeighborsInterpolation<NumericType> interpolation;
    interpolation.setDistanceExponent(distanceExponent);
    interpolation.setNumberOfNeighbors(numberOfNeighbors);
    interpolation.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.get();
    interpolation.setData(data);

    psCSVWriter<NumericType> writer(
        "nn_std_output.csv",
        "x, y, z, data\nData generated by nearest neighbors interpolation");

    if (interpolation.initialize() && writer.initialize())
      for (int i = 0; i < numSamples; ++i)
        for (int j = 0; j < numSamples; ++j)
          for (int k = 0; k < numSamples; ++k) {
            std::vector<NumericType> x(InputDim);

            // Extrapolate
            x[0] = .1 + i * (.8 - .1) / (numSamples - 1);
            x[1] = -6. + j * (8. + 6.) / (numSamples - 1);
            x[2] = -6. + k * (1. + 6.) / (numSamples - 1);

            auto estimateOpt = interpolation.estimate(x);
            if (!estimateOpt)
              continue;

            // We use structural bindings to directly unpack the tuple
            auto [value, minDistance] = estimateOpt.value();

            writer.writeRow({x[0], x[1], x[2], value[0]});
          }
  }

  {
    psCSVDataSource<NumericType> dataSource;
    dataSource.setFilename((dataPath / "scatterdata.csv").string());

    int numberOfNeighbors = 5;
    NumericType distanceExponent = 1. / 5.;

    psNearestNeighborsInterpolation<NumericType,
                                    psMedianDistanceScaler<NumericType>>
        interpolation;
    interpolation.setDistanceExponent(distanceExponent);
    interpolation.setNumberOfNeighbors(numberOfNeighbors);
    interpolation.setDataDimensions(InputDim, OutputDim);

    auto data = dataSource.get();
    interpolation.setData(data);

    psCSVWriter<NumericType> writer(
        "nn_median_output.csv",
        "x, y, z, data\nData generated by nearest neighbors interpolation");

    if (interpolation.initialize() && writer.initialize())
      for (int i = 0; i < numSamples; ++i)
        for (int j = 0; j < numSamples; ++j)
          for (int k = 0; k < numSamples; ++k) {
            std::vector<NumericType> x(InputDim);

            // Extrapolate
            x[0] = .1 + i * (.8 - .1) / (numSamples - 1);
            x[1] = -6. + j * (8. + 6.) / (numSamples - 1);
            x[2] = -6. + k * (1. + 6.) / (numSamples - 1);

            auto estimateOpt = interpolation.estimate(x);
            if (!estimateOpt)
              continue;

            // We use structural bindings to directly unpack the tuple
            auto [value, minDistance] = estimateOpt.value();

            writer.writeRow({x[0], x[1], x[2], value[0]});
          }
  }

  return EXIT_SUCCESS;
}
